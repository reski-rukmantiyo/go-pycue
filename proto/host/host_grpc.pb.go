// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: OpenCue/proto/host.proto

package host

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	DeedInterface_Delete_FullMethodName   = "/host.DeedInterface/Delete"
	DeedInterface_GetHost_FullMethodName  = "/host.DeedInterface/GetHost"
	DeedInterface_GetOwner_FullMethodName = "/host.DeedInterface/GetOwner"
)

// DeedInterfaceClient is the client API for DeedInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeedInterfaceClient interface {
	// Remove the deed
	Delete(ctx context.Context, in *DeedDeleteRequest, opts ...grpc.CallOption) (*DeedDeleteResponse, error)
	// Returns the full host for these settings.
	GetHost(ctx context.Context, in *DeedGetHostRequest, opts ...grpc.CallOption) (*DeedGetHostResponse, error)
	// Returns the owner for these settings.
	GetOwner(ctx context.Context, in *DeedGetOwnerRequest, opts ...grpc.CallOption) (*DeedGetOwnerResponse, error)
}

type deedInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeedInterfaceClient(cc grpc.ClientConnInterface) DeedInterfaceClient {
	return &deedInterfaceClient{cc}
}

func (c *deedInterfaceClient) Delete(ctx context.Context, in *DeedDeleteRequest, opts ...grpc.CallOption) (*DeedDeleteResponse, error) {
	out := new(DeedDeleteResponse)
	err := c.cc.Invoke(ctx, DeedInterface_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deedInterfaceClient) GetHost(ctx context.Context, in *DeedGetHostRequest, opts ...grpc.CallOption) (*DeedGetHostResponse, error) {
	out := new(DeedGetHostResponse)
	err := c.cc.Invoke(ctx, DeedInterface_GetHost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deedInterfaceClient) GetOwner(ctx context.Context, in *DeedGetOwnerRequest, opts ...grpc.CallOption) (*DeedGetOwnerResponse, error) {
	out := new(DeedGetOwnerResponse)
	err := c.cc.Invoke(ctx, DeedInterface_GetOwner_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeedInterfaceServer is the server API for DeedInterface service.
// All implementations must embed UnimplementedDeedInterfaceServer
// for forward compatibility
type DeedInterfaceServer interface {
	// Remove the deed
	Delete(context.Context, *DeedDeleteRequest) (*DeedDeleteResponse, error)
	// Returns the full host for these settings.
	GetHost(context.Context, *DeedGetHostRequest) (*DeedGetHostResponse, error)
	// Returns the owner for these settings.
	GetOwner(context.Context, *DeedGetOwnerRequest) (*DeedGetOwnerResponse, error)
	mustEmbedUnimplementedDeedInterfaceServer()
}

// UnimplementedDeedInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedDeedInterfaceServer struct {
}

func (UnimplementedDeedInterfaceServer) Delete(context.Context, *DeedDeleteRequest) (*DeedDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDeedInterfaceServer) GetHost(context.Context, *DeedGetHostRequest) (*DeedGetHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHost not implemented")
}
func (UnimplementedDeedInterfaceServer) GetOwner(context.Context, *DeedGetOwnerRequest) (*DeedGetOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOwner not implemented")
}
func (UnimplementedDeedInterfaceServer) mustEmbedUnimplementedDeedInterfaceServer() {}

// UnsafeDeedInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeedInterfaceServer will
// result in compilation errors.
type UnsafeDeedInterfaceServer interface {
	mustEmbedUnimplementedDeedInterfaceServer()
}

func RegisterDeedInterfaceServer(s grpc.ServiceRegistrar, srv DeedInterfaceServer) {
	s.RegisterService(&DeedInterface_ServiceDesc, srv)
}

func _DeedInterface_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeedDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeedInterfaceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeedInterface_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeedInterfaceServer).Delete(ctx, req.(*DeedDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeedInterface_GetHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeedGetHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeedInterfaceServer).GetHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeedInterface_GetHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeedInterfaceServer).GetHost(ctx, req.(*DeedGetHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeedInterface_GetOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeedGetOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeedInterfaceServer).GetOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeedInterface_GetOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeedInterfaceServer).GetOwner(ctx, req.(*DeedGetOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeedInterface_ServiceDesc is the grpc.ServiceDesc for DeedInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeedInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "host.DeedInterface",
	HandlerType: (*DeedInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _DeedInterface_Delete_Handler,
		},
		{
			MethodName: "GetHost",
			Handler:    _DeedInterface_GetHost_Handler,
		},
		{
			MethodName: "GetOwner",
			Handler:    _DeedInterface_GetOwner_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/host.proto",
}

const (
	HostInterface_AddComment_FullMethodName          = "/host.HostInterface/AddComment"
	HostInterface_AddTags_FullMethodName             = "/host.HostInterface/AddTags"
	HostInterface_Delete_FullMethodName              = "/host.HostInterface/Delete"
	HostInterface_FindHost_FullMethodName            = "/host.HostInterface/FindHost"
	HostInterface_GetComments_FullMethodName         = "/host.HostInterface/GetComments"
	HostInterface_GetDeed_FullMethodName             = "/host.HostInterface/GetDeed"
	HostInterface_GetHost_FullMethodName             = "/host.HostInterface/GetHost"
	HostInterface_GetHosts_FullMethodName            = "/host.HostInterface/GetHosts"
	HostInterface_GetHostWhiteboard_FullMethodName   = "/host.HostInterface/GetHostWhiteboard"
	HostInterface_GetOwner_FullMethodName            = "/host.HostInterface/GetOwner"
	HostInterface_GetProcs_FullMethodName            = "/host.HostInterface/GetProcs"
	HostInterface_GetRenderPartitions_FullMethodName = "/host.HostInterface/GetRenderPartitions"
	HostInterface_Lock_FullMethodName                = "/host.HostInterface/Lock"
	HostInterface_Reboot_FullMethodName              = "/host.HostInterface/Reboot"
	HostInterface_RebootWhenIdle_FullMethodName      = "/host.HostInterface/RebootWhenIdle"
	HostInterface_RedirectToJob_FullMethodName       = "/host.HostInterface/RedirectToJob"
	HostInterface_RemoveTags_FullMethodName          = "/host.HostInterface/RemoveTags"
	HostInterface_RenameTag_FullMethodName           = "/host.HostInterface/RenameTag"
	HostInterface_SetAllocation_FullMethodName       = "/host.HostInterface/SetAllocation"
	HostInterface_SetHardwareState_FullMethodName    = "/host.HostInterface/SetHardwareState"
	HostInterface_SetOs_FullMethodName               = "/host.HostInterface/SetOs"
	HostInterface_SetThreadMode_FullMethodName       = "/host.HostInterface/SetThreadMode"
	HostInterface_Unlock_FullMethodName              = "/host.HostInterface/Unlock"
)

// HostInterfaceClient is the client API for HostInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HostInterfaceClient interface {
	// Add a comment on this host.
	AddComment(ctx context.Context, in *HostAddCommentRequest, opts ...grpc.CallOption) (*HostAddCommentResponse, error)
	// Set a tag on this host.
	AddTags(ctx context.Context, in *HostAddTagsRequest, opts ...grpc.CallOption) (*HostAddTagsResponse, error)
	// Delete host.
	Delete(ctx context.Context, in *HostDeleteRequest, opts ...grpc.CallOption) (*HostDeleteResponse, error)
	// Find a host by its name
	FindHost(ctx context.Context, in *HostFindHostRequest, opts ...grpc.CallOption) (*HostFindHostResponse, error)
	// Get the comments for this host.
	GetComments(ctx context.Context, in *HostGetCommentsRequest, opts ...grpc.CallOption) (*HostGetCommentsResponse, error)
	// Return the deed for this host.
	GetDeed(ctx context.Context, in *HostGetDeedRequest, opts ...grpc.CallOption) (*HostGetDeedResponse, error)
	// Return a host by its id
	GetHost(ctx context.Context, in *HostGetHostRequest, opts ...grpc.CallOption) (*HostGetHostResponse, error)
	// Search for a number of hosts
	GetHosts(ctx context.Context, in *HostGetHostsRequest, opts ...grpc.CallOption) (*HostGetHostsResponse, error)
	// Return the host whiteboard
	GetHostWhiteboard(ctx context.Context, in *HostGetHostWhiteboardRequest, opts ...grpc.CallOption) (*HostGetHostWhiteboardResponse, error)
	// Get the owner settings of this particular host.
	GetOwner(ctx context.Context, in *HostGetOwnerRequest, opts ...grpc.CallOption) (*HostGetOwnerResponse, error)
	// Returns the list of proc resources allocated from this host.
	GetProcs(ctx context.Context, in *HostGetProcsRequest, opts ...grpc.CallOption) (*HostGetProcsResponse, error)
	// Return any render partitions that are setup on this host.
	GetRenderPartitions(ctx context.Context, in *HostGetRenderPartitionsRequest, opts ...grpc.CallOption) (*HostGetRenderPartitionsResponse, error)
	// Locks the host.  Its possible we'll need to pass in a show name here in the future
	Lock(ctx context.Context, in *HostLockRequest, opts ...grpc.CallOption) (*HostLockResponse, error)
	// Issues an immediate reboot.
	Reboot(ctx context.Context, in *HostRebootRequest, opts ...grpc.CallOption) (*HostRebootResponse, error)
	// Sets the reboot when idle state, nothing has to be locked to set this. When the host pings in idle a reboot
	// command is sent to the host and the host will be put into the Rebooting state.  If any locks are set they will
	// be removed upon reboot.
	RebootWhenIdle(ctx context.Context, in *HostRebootWhenIdleRequest, opts ...grpc.CallOption) (*HostRebootWhenIdleResponse, error)
	// Redirect the given procs to the specified job.
	RedirectToJob(ctx context.Context, in *HostRedirectToJobRequest, opts ...grpc.CallOption) (*HostRedirectToJobResponse, error)
	// Remove a tag from this host.
	RemoveTags(ctx context.Context, in *HostRemoveTagsRequest, opts ...grpc.CallOption) (*HostRemoveTagsResponse, error)
	// Rename tag.
	RenameTag(ctx context.Context, in *HostRenameTagRequest, opts ...grpc.CallOption) (*HostRenameTagResponse, error)
	// Assign a host to an allocation.
	SetAllocation(ctx context.Context, in *HostSetAllocationRequest, opts ...grpc.CallOption) (*HostSetAllocationResponse, error)
	// Manually set the hardware state for the host.  The hardware state may be changed automatically if the host pings
	// in.  If the hardware state is set to "Reimage", the state will not automatically change with a host ping, and
	// must be manually set back to Up.
	SetHardwareState(ctx context.Context, in *HostSetHardwareStateRequest, opts ...grpc.CallOption) (*HostSetHardwareStateResponse, error)
	// Set the name of the host operating system.
	SetOs(ctx context.Context, in *HostSetOsRequest, opts ...grpc.CallOption) (*HostSetOsResponse, error)
	// Changes the host's [ThreadMode]
	SetThreadMode(ctx context.Context, in *HostSetThreadModeRequest, opts ...grpc.CallOption) (*HostSetThreadModeResponse, error)
	// Unlocks the host for booking if the proc is in the Locked state. You cannot unlock a NimbyLocked proc.
	Unlock(ctx context.Context, in *HostUnlockRequest, opts ...grpc.CallOption) (*HostUnlockResponse, error)
}

type hostInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewHostInterfaceClient(cc grpc.ClientConnInterface) HostInterfaceClient {
	return &hostInterfaceClient{cc}
}

func (c *hostInterfaceClient) AddComment(ctx context.Context, in *HostAddCommentRequest, opts ...grpc.CallOption) (*HostAddCommentResponse, error) {
	out := new(HostAddCommentResponse)
	err := c.cc.Invoke(ctx, HostInterface_AddComment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) AddTags(ctx context.Context, in *HostAddTagsRequest, opts ...grpc.CallOption) (*HostAddTagsResponse, error) {
	out := new(HostAddTagsResponse)
	err := c.cc.Invoke(ctx, HostInterface_AddTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) Delete(ctx context.Context, in *HostDeleteRequest, opts ...grpc.CallOption) (*HostDeleteResponse, error) {
	out := new(HostDeleteResponse)
	err := c.cc.Invoke(ctx, HostInterface_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) FindHost(ctx context.Context, in *HostFindHostRequest, opts ...grpc.CallOption) (*HostFindHostResponse, error) {
	out := new(HostFindHostResponse)
	err := c.cc.Invoke(ctx, HostInterface_FindHost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetComments(ctx context.Context, in *HostGetCommentsRequest, opts ...grpc.CallOption) (*HostGetCommentsResponse, error) {
	out := new(HostGetCommentsResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetComments_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetDeed(ctx context.Context, in *HostGetDeedRequest, opts ...grpc.CallOption) (*HostGetDeedResponse, error) {
	out := new(HostGetDeedResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetDeed_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetHost(ctx context.Context, in *HostGetHostRequest, opts ...grpc.CallOption) (*HostGetHostResponse, error) {
	out := new(HostGetHostResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetHost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetHosts(ctx context.Context, in *HostGetHostsRequest, opts ...grpc.CallOption) (*HostGetHostsResponse, error) {
	out := new(HostGetHostsResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetHosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetHostWhiteboard(ctx context.Context, in *HostGetHostWhiteboardRequest, opts ...grpc.CallOption) (*HostGetHostWhiteboardResponse, error) {
	out := new(HostGetHostWhiteboardResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetHostWhiteboard_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetOwner(ctx context.Context, in *HostGetOwnerRequest, opts ...grpc.CallOption) (*HostGetOwnerResponse, error) {
	out := new(HostGetOwnerResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetOwner_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetProcs(ctx context.Context, in *HostGetProcsRequest, opts ...grpc.CallOption) (*HostGetProcsResponse, error) {
	out := new(HostGetProcsResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetProcs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) GetRenderPartitions(ctx context.Context, in *HostGetRenderPartitionsRequest, opts ...grpc.CallOption) (*HostGetRenderPartitionsResponse, error) {
	out := new(HostGetRenderPartitionsResponse)
	err := c.cc.Invoke(ctx, HostInterface_GetRenderPartitions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) Lock(ctx context.Context, in *HostLockRequest, opts ...grpc.CallOption) (*HostLockResponse, error) {
	out := new(HostLockResponse)
	err := c.cc.Invoke(ctx, HostInterface_Lock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) Reboot(ctx context.Context, in *HostRebootRequest, opts ...grpc.CallOption) (*HostRebootResponse, error) {
	out := new(HostRebootResponse)
	err := c.cc.Invoke(ctx, HostInterface_Reboot_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) RebootWhenIdle(ctx context.Context, in *HostRebootWhenIdleRequest, opts ...grpc.CallOption) (*HostRebootWhenIdleResponse, error) {
	out := new(HostRebootWhenIdleResponse)
	err := c.cc.Invoke(ctx, HostInterface_RebootWhenIdle_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) RedirectToJob(ctx context.Context, in *HostRedirectToJobRequest, opts ...grpc.CallOption) (*HostRedirectToJobResponse, error) {
	out := new(HostRedirectToJobResponse)
	err := c.cc.Invoke(ctx, HostInterface_RedirectToJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) RemoveTags(ctx context.Context, in *HostRemoveTagsRequest, opts ...grpc.CallOption) (*HostRemoveTagsResponse, error) {
	out := new(HostRemoveTagsResponse)
	err := c.cc.Invoke(ctx, HostInterface_RemoveTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) RenameTag(ctx context.Context, in *HostRenameTagRequest, opts ...grpc.CallOption) (*HostRenameTagResponse, error) {
	out := new(HostRenameTagResponse)
	err := c.cc.Invoke(ctx, HostInterface_RenameTag_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) SetAllocation(ctx context.Context, in *HostSetAllocationRequest, opts ...grpc.CallOption) (*HostSetAllocationResponse, error) {
	out := new(HostSetAllocationResponse)
	err := c.cc.Invoke(ctx, HostInterface_SetAllocation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) SetHardwareState(ctx context.Context, in *HostSetHardwareStateRequest, opts ...grpc.CallOption) (*HostSetHardwareStateResponse, error) {
	out := new(HostSetHardwareStateResponse)
	err := c.cc.Invoke(ctx, HostInterface_SetHardwareState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) SetOs(ctx context.Context, in *HostSetOsRequest, opts ...grpc.CallOption) (*HostSetOsResponse, error) {
	out := new(HostSetOsResponse)
	err := c.cc.Invoke(ctx, HostInterface_SetOs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) SetThreadMode(ctx context.Context, in *HostSetThreadModeRequest, opts ...grpc.CallOption) (*HostSetThreadModeResponse, error) {
	out := new(HostSetThreadModeResponse)
	err := c.cc.Invoke(ctx, HostInterface_SetThreadMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostInterfaceClient) Unlock(ctx context.Context, in *HostUnlockRequest, opts ...grpc.CallOption) (*HostUnlockResponse, error) {
	out := new(HostUnlockResponse)
	err := c.cc.Invoke(ctx, HostInterface_Unlock_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostInterfaceServer is the server API for HostInterface service.
// All implementations must embed UnimplementedHostInterfaceServer
// for forward compatibility
type HostInterfaceServer interface {
	// Add a comment on this host.
	AddComment(context.Context, *HostAddCommentRequest) (*HostAddCommentResponse, error)
	// Set a tag on this host.
	AddTags(context.Context, *HostAddTagsRequest) (*HostAddTagsResponse, error)
	// Delete host.
	Delete(context.Context, *HostDeleteRequest) (*HostDeleteResponse, error)
	// Find a host by its name
	FindHost(context.Context, *HostFindHostRequest) (*HostFindHostResponse, error)
	// Get the comments for this host.
	GetComments(context.Context, *HostGetCommentsRequest) (*HostGetCommentsResponse, error)
	// Return the deed for this host.
	GetDeed(context.Context, *HostGetDeedRequest) (*HostGetDeedResponse, error)
	// Return a host by its id
	GetHost(context.Context, *HostGetHostRequest) (*HostGetHostResponse, error)
	// Search for a number of hosts
	GetHosts(context.Context, *HostGetHostsRequest) (*HostGetHostsResponse, error)
	// Return the host whiteboard
	GetHostWhiteboard(context.Context, *HostGetHostWhiteboardRequest) (*HostGetHostWhiteboardResponse, error)
	// Get the owner settings of this particular host.
	GetOwner(context.Context, *HostGetOwnerRequest) (*HostGetOwnerResponse, error)
	// Returns the list of proc resources allocated from this host.
	GetProcs(context.Context, *HostGetProcsRequest) (*HostGetProcsResponse, error)
	// Return any render partitions that are setup on this host.
	GetRenderPartitions(context.Context, *HostGetRenderPartitionsRequest) (*HostGetRenderPartitionsResponse, error)
	// Locks the host.  Its possible we'll need to pass in a show name here in the future
	Lock(context.Context, *HostLockRequest) (*HostLockResponse, error)
	// Issues an immediate reboot.
	Reboot(context.Context, *HostRebootRequest) (*HostRebootResponse, error)
	// Sets the reboot when idle state, nothing has to be locked to set this. When the host pings in idle a reboot
	// command is sent to the host and the host will be put into the Rebooting state.  If any locks are set they will
	// be removed upon reboot.
	RebootWhenIdle(context.Context, *HostRebootWhenIdleRequest) (*HostRebootWhenIdleResponse, error)
	// Redirect the given procs to the specified job.
	RedirectToJob(context.Context, *HostRedirectToJobRequest) (*HostRedirectToJobResponse, error)
	// Remove a tag from this host.
	RemoveTags(context.Context, *HostRemoveTagsRequest) (*HostRemoveTagsResponse, error)
	// Rename tag.
	RenameTag(context.Context, *HostRenameTagRequest) (*HostRenameTagResponse, error)
	// Assign a host to an allocation.
	SetAllocation(context.Context, *HostSetAllocationRequest) (*HostSetAllocationResponse, error)
	// Manually set the hardware state for the host.  The hardware state may be changed automatically if the host pings
	// in.  If the hardware state is set to "Reimage", the state will not automatically change with a host ping, and
	// must be manually set back to Up.
	SetHardwareState(context.Context, *HostSetHardwareStateRequest) (*HostSetHardwareStateResponse, error)
	// Set the name of the host operating system.
	SetOs(context.Context, *HostSetOsRequest) (*HostSetOsResponse, error)
	// Changes the host's [ThreadMode]
	SetThreadMode(context.Context, *HostSetThreadModeRequest) (*HostSetThreadModeResponse, error)
	// Unlocks the host for booking if the proc is in the Locked state. You cannot unlock a NimbyLocked proc.
	Unlock(context.Context, *HostUnlockRequest) (*HostUnlockResponse, error)
	mustEmbedUnimplementedHostInterfaceServer()
}

// UnimplementedHostInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedHostInterfaceServer struct {
}

func (UnimplementedHostInterfaceServer) AddComment(context.Context, *HostAddCommentRequest) (*HostAddCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddComment not implemented")
}
func (UnimplementedHostInterfaceServer) AddTags(context.Context, *HostAddTagsRequest) (*HostAddTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTags not implemented")
}
func (UnimplementedHostInterfaceServer) Delete(context.Context, *HostDeleteRequest) (*HostDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedHostInterfaceServer) FindHost(context.Context, *HostFindHostRequest) (*HostFindHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindHost not implemented")
}
func (UnimplementedHostInterfaceServer) GetComments(context.Context, *HostGetCommentsRequest) (*HostGetCommentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComments not implemented")
}
func (UnimplementedHostInterfaceServer) GetDeed(context.Context, *HostGetDeedRequest) (*HostGetDeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeed not implemented")
}
func (UnimplementedHostInterfaceServer) GetHost(context.Context, *HostGetHostRequest) (*HostGetHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHost not implemented")
}
func (UnimplementedHostInterfaceServer) GetHosts(context.Context, *HostGetHostsRequest) (*HostGetHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHosts not implemented")
}
func (UnimplementedHostInterfaceServer) GetHostWhiteboard(context.Context, *HostGetHostWhiteboardRequest) (*HostGetHostWhiteboardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostWhiteboard not implemented")
}
func (UnimplementedHostInterfaceServer) GetOwner(context.Context, *HostGetOwnerRequest) (*HostGetOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOwner not implemented")
}
func (UnimplementedHostInterfaceServer) GetProcs(context.Context, *HostGetProcsRequest) (*HostGetProcsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcs not implemented")
}
func (UnimplementedHostInterfaceServer) GetRenderPartitions(context.Context, *HostGetRenderPartitionsRequest) (*HostGetRenderPartitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRenderPartitions not implemented")
}
func (UnimplementedHostInterfaceServer) Lock(context.Context, *HostLockRequest) (*HostLockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedHostInterfaceServer) Reboot(context.Context, *HostRebootRequest) (*HostRebootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reboot not implemented")
}
func (UnimplementedHostInterfaceServer) RebootWhenIdle(context.Context, *HostRebootWhenIdleRequest) (*HostRebootWhenIdleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebootWhenIdle not implemented")
}
func (UnimplementedHostInterfaceServer) RedirectToJob(context.Context, *HostRedirectToJobRequest) (*HostRedirectToJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectToJob not implemented")
}
func (UnimplementedHostInterfaceServer) RemoveTags(context.Context, *HostRemoveTagsRequest) (*HostRemoveTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveTags not implemented")
}
func (UnimplementedHostInterfaceServer) RenameTag(context.Context, *HostRenameTagRequest) (*HostRenameTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameTag not implemented")
}
func (UnimplementedHostInterfaceServer) SetAllocation(context.Context, *HostSetAllocationRequest) (*HostSetAllocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAllocation not implemented")
}
func (UnimplementedHostInterfaceServer) SetHardwareState(context.Context, *HostSetHardwareStateRequest) (*HostSetHardwareStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetHardwareState not implemented")
}
func (UnimplementedHostInterfaceServer) SetOs(context.Context, *HostSetOsRequest) (*HostSetOsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetOs not implemented")
}
func (UnimplementedHostInterfaceServer) SetThreadMode(context.Context, *HostSetThreadModeRequest) (*HostSetThreadModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetThreadMode not implemented")
}
func (UnimplementedHostInterfaceServer) Unlock(context.Context, *HostUnlockRequest) (*HostUnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedHostInterfaceServer) mustEmbedUnimplementedHostInterfaceServer() {}

// UnsafeHostInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostInterfaceServer will
// result in compilation errors.
type UnsafeHostInterfaceServer interface {
	mustEmbedUnimplementedHostInterfaceServer()
}

func RegisterHostInterfaceServer(s grpc.ServiceRegistrar, srv HostInterfaceServer) {
	s.RegisterService(&HostInterface_ServiceDesc, srv)
}

func _HostInterface_AddComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostAddCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).AddComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_AddComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).AddComment(ctx, req.(*HostAddCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_AddTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostAddTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).AddTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_AddTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).AddTags(ctx, req.(*HostAddTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).Delete(ctx, req.(*HostDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_FindHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostFindHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).FindHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_FindHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).FindHost(ctx, req.(*HostFindHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetComments(ctx, req.(*HostGetCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetDeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetDeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetDeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetDeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetDeed(ctx, req.(*HostGetDeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetHost(ctx, req.(*HostGetHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetHosts(ctx, req.(*HostGetHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetHostWhiteboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetHostWhiteboardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetHostWhiteboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetHostWhiteboard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetHostWhiteboard(ctx, req.(*HostGetHostWhiteboardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetOwner(ctx, req.(*HostGetOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetProcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetProcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetProcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetProcs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetProcs(ctx, req.(*HostGetProcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_GetRenderPartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostGetRenderPartitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).GetRenderPartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_GetRenderPartitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).GetRenderPartitions(ctx, req.(*HostGetRenderPartitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).Lock(ctx, req.(*HostLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_Reboot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostRebootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).Reboot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_Reboot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).Reboot(ctx, req.(*HostRebootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_RebootWhenIdle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostRebootWhenIdleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).RebootWhenIdle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_RebootWhenIdle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).RebootWhenIdle(ctx, req.(*HostRebootWhenIdleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_RedirectToJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostRedirectToJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).RedirectToJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_RedirectToJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).RedirectToJob(ctx, req.(*HostRedirectToJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_RemoveTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostRemoveTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).RemoveTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_RemoveTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).RemoveTags(ctx, req.(*HostRemoveTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_RenameTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostRenameTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).RenameTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_RenameTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).RenameTag(ctx, req.(*HostRenameTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_SetAllocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostSetAllocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).SetAllocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_SetAllocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).SetAllocation(ctx, req.(*HostSetAllocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_SetHardwareState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostSetHardwareStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).SetHardwareState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_SetHardwareState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).SetHardwareState(ctx, req.(*HostSetHardwareStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_SetOs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostSetOsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).SetOs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_SetOs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).SetOs(ctx, req.(*HostSetOsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_SetThreadMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostSetThreadModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).SetThreadMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_SetThreadMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).SetThreadMode(ctx, req.(*HostSetThreadModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostInterface_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostUnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostInterfaceServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HostInterface_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostInterfaceServer).Unlock(ctx, req.(*HostUnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HostInterface_ServiceDesc is the grpc.ServiceDesc for HostInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HostInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "host.HostInterface",
	HandlerType: (*HostInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddComment",
			Handler:    _HostInterface_AddComment_Handler,
		},
		{
			MethodName: "AddTags",
			Handler:    _HostInterface_AddTags_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _HostInterface_Delete_Handler,
		},
		{
			MethodName: "FindHost",
			Handler:    _HostInterface_FindHost_Handler,
		},
		{
			MethodName: "GetComments",
			Handler:    _HostInterface_GetComments_Handler,
		},
		{
			MethodName: "GetDeed",
			Handler:    _HostInterface_GetDeed_Handler,
		},
		{
			MethodName: "GetHost",
			Handler:    _HostInterface_GetHost_Handler,
		},
		{
			MethodName: "GetHosts",
			Handler:    _HostInterface_GetHosts_Handler,
		},
		{
			MethodName: "GetHostWhiteboard",
			Handler:    _HostInterface_GetHostWhiteboard_Handler,
		},
		{
			MethodName: "GetOwner",
			Handler:    _HostInterface_GetOwner_Handler,
		},
		{
			MethodName: "GetProcs",
			Handler:    _HostInterface_GetProcs_Handler,
		},
		{
			MethodName: "GetRenderPartitions",
			Handler:    _HostInterface_GetRenderPartitions_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _HostInterface_Lock_Handler,
		},
		{
			MethodName: "Reboot",
			Handler:    _HostInterface_Reboot_Handler,
		},
		{
			MethodName: "RebootWhenIdle",
			Handler:    _HostInterface_RebootWhenIdle_Handler,
		},
		{
			MethodName: "RedirectToJob",
			Handler:    _HostInterface_RedirectToJob_Handler,
		},
		{
			MethodName: "RemoveTags",
			Handler:    _HostInterface_RemoveTags_Handler,
		},
		{
			MethodName: "RenameTag",
			Handler:    _HostInterface_RenameTag_Handler,
		},
		{
			MethodName: "SetAllocation",
			Handler:    _HostInterface_SetAllocation_Handler,
		},
		{
			MethodName: "SetHardwareState",
			Handler:    _HostInterface_SetHardwareState_Handler,
		},
		{
			MethodName: "SetOs",
			Handler:    _HostInterface_SetOs_Handler,
		},
		{
			MethodName: "SetThreadMode",
			Handler:    _HostInterface_SetThreadMode_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _HostInterface_Unlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/host.proto",
}

const (
	OwnerInterface_Delete_FullMethodName        = "/host.OwnerInterface/Delete"
	OwnerInterface_GetDeeds_FullMethodName      = "/host.OwnerInterface/GetDeeds"
	OwnerInterface_GetHosts_FullMethodName      = "/host.OwnerInterface/GetHosts"
	OwnerInterface_GetOwner_FullMethodName      = "/host.OwnerInterface/GetOwner"
	OwnerInterface_SetShow_FullMethodName       = "/host.OwnerInterface/SetShow"
	OwnerInterface_TakeOwnership_FullMethodName = "/host.OwnerInterface/TakeOwnership"
)

// OwnerInterfaceClient is the client API for OwnerInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OwnerInterfaceClient interface {
	// Deletes the owner record.
	Delete(ctx context.Context, in *OwnerDeleteRequest, opts ...grpc.CallOption) (*OwnerDeleteResponse, error)
	// Get a list of all deeds this owner has.
	GetDeeds(ctx context.Context, in *OwnerGetDeedsRequest, opts ...grpc.CallOption) (*OwnerGetDeedsResponse, error)
	// Get a list of all hosts this owner is responsible for.
	GetHosts(ctx context.Context, in *OwnerGetHostsRequest, opts ...grpc.CallOption) (*OwnerGetHostsResponse, error)
	// Return an Owner record by name, id, or email.
	GetOwner(ctx context.Context, in *OwnerGetOwnerRequest, opts ...grpc.CallOption) (*OwnerGetOwnerResponse, error)
	// Sets the owners show.
	SetShow(ctx context.Context, in *OwnerSetShowRequest, opts ...grpc.CallOption) (*OwnerSetShowResponse, error)
	// Set the hosts new owner settings.  Any host may have an owner, not just desktops.  This allows direct control of
	// the cores.  By default hosts have no owner settings.
	TakeOwnership(ctx context.Context, in *OwnerTakeOwnershipRequest, opts ...grpc.CallOption) (*OwnerTakeOwnershipResponse, error)
}

type ownerInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewOwnerInterfaceClient(cc grpc.ClientConnInterface) OwnerInterfaceClient {
	return &ownerInterfaceClient{cc}
}

func (c *ownerInterfaceClient) Delete(ctx context.Context, in *OwnerDeleteRequest, opts ...grpc.CallOption) (*OwnerDeleteResponse, error) {
	out := new(OwnerDeleteResponse)
	err := c.cc.Invoke(ctx, OwnerInterface_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownerInterfaceClient) GetDeeds(ctx context.Context, in *OwnerGetDeedsRequest, opts ...grpc.CallOption) (*OwnerGetDeedsResponse, error) {
	out := new(OwnerGetDeedsResponse)
	err := c.cc.Invoke(ctx, OwnerInterface_GetDeeds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownerInterfaceClient) GetHosts(ctx context.Context, in *OwnerGetHostsRequest, opts ...grpc.CallOption) (*OwnerGetHostsResponse, error) {
	out := new(OwnerGetHostsResponse)
	err := c.cc.Invoke(ctx, OwnerInterface_GetHosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownerInterfaceClient) GetOwner(ctx context.Context, in *OwnerGetOwnerRequest, opts ...grpc.CallOption) (*OwnerGetOwnerResponse, error) {
	out := new(OwnerGetOwnerResponse)
	err := c.cc.Invoke(ctx, OwnerInterface_GetOwner_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownerInterfaceClient) SetShow(ctx context.Context, in *OwnerSetShowRequest, opts ...grpc.CallOption) (*OwnerSetShowResponse, error) {
	out := new(OwnerSetShowResponse)
	err := c.cc.Invoke(ctx, OwnerInterface_SetShow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ownerInterfaceClient) TakeOwnership(ctx context.Context, in *OwnerTakeOwnershipRequest, opts ...grpc.CallOption) (*OwnerTakeOwnershipResponse, error) {
	out := new(OwnerTakeOwnershipResponse)
	err := c.cc.Invoke(ctx, OwnerInterface_TakeOwnership_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OwnerInterfaceServer is the server API for OwnerInterface service.
// All implementations must embed UnimplementedOwnerInterfaceServer
// for forward compatibility
type OwnerInterfaceServer interface {
	// Deletes the owner record.
	Delete(context.Context, *OwnerDeleteRequest) (*OwnerDeleteResponse, error)
	// Get a list of all deeds this owner has.
	GetDeeds(context.Context, *OwnerGetDeedsRequest) (*OwnerGetDeedsResponse, error)
	// Get a list of all hosts this owner is responsible for.
	GetHosts(context.Context, *OwnerGetHostsRequest) (*OwnerGetHostsResponse, error)
	// Return an Owner record by name, id, or email.
	GetOwner(context.Context, *OwnerGetOwnerRequest) (*OwnerGetOwnerResponse, error)
	// Sets the owners show.
	SetShow(context.Context, *OwnerSetShowRequest) (*OwnerSetShowResponse, error)
	// Set the hosts new owner settings.  Any host may have an owner, not just desktops.  This allows direct control of
	// the cores.  By default hosts have no owner settings.
	TakeOwnership(context.Context, *OwnerTakeOwnershipRequest) (*OwnerTakeOwnershipResponse, error)
	mustEmbedUnimplementedOwnerInterfaceServer()
}

// UnimplementedOwnerInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedOwnerInterfaceServer struct {
}

func (UnimplementedOwnerInterfaceServer) Delete(context.Context, *OwnerDeleteRequest) (*OwnerDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedOwnerInterfaceServer) GetDeeds(context.Context, *OwnerGetDeedsRequest) (*OwnerGetDeedsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeeds not implemented")
}
func (UnimplementedOwnerInterfaceServer) GetHosts(context.Context, *OwnerGetHostsRequest) (*OwnerGetHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHosts not implemented")
}
func (UnimplementedOwnerInterfaceServer) GetOwner(context.Context, *OwnerGetOwnerRequest) (*OwnerGetOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOwner not implemented")
}
func (UnimplementedOwnerInterfaceServer) SetShow(context.Context, *OwnerSetShowRequest) (*OwnerSetShowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetShow not implemented")
}
func (UnimplementedOwnerInterfaceServer) TakeOwnership(context.Context, *OwnerTakeOwnershipRequest) (*OwnerTakeOwnershipResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeOwnership not implemented")
}
func (UnimplementedOwnerInterfaceServer) mustEmbedUnimplementedOwnerInterfaceServer() {}

// UnsafeOwnerInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OwnerInterfaceServer will
// result in compilation errors.
type UnsafeOwnerInterfaceServer interface {
	mustEmbedUnimplementedOwnerInterfaceServer()
}

func RegisterOwnerInterfaceServer(s grpc.ServiceRegistrar, srv OwnerInterfaceServer) {
	s.RegisterService(&OwnerInterface_ServiceDesc, srv)
}

func _OwnerInterface_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OwnerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnerInterfaceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnerInterface_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnerInterfaceServer).Delete(ctx, req.(*OwnerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnerInterface_GetDeeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OwnerGetDeedsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnerInterfaceServer).GetDeeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnerInterface_GetDeeds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnerInterfaceServer).GetDeeds(ctx, req.(*OwnerGetDeedsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnerInterface_GetHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OwnerGetHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnerInterfaceServer).GetHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnerInterface_GetHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnerInterfaceServer).GetHosts(ctx, req.(*OwnerGetHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnerInterface_GetOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OwnerGetOwnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnerInterfaceServer).GetOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnerInterface_GetOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnerInterfaceServer).GetOwner(ctx, req.(*OwnerGetOwnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnerInterface_SetShow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OwnerSetShowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnerInterfaceServer).SetShow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnerInterface_SetShow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnerInterfaceServer).SetShow(ctx, req.(*OwnerSetShowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OwnerInterface_TakeOwnership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OwnerTakeOwnershipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OwnerInterfaceServer).TakeOwnership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OwnerInterface_TakeOwnership_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OwnerInterfaceServer).TakeOwnership(ctx, req.(*OwnerTakeOwnershipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OwnerInterface_ServiceDesc is the grpc.ServiceDesc for OwnerInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OwnerInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "host.OwnerInterface",
	HandlerType: (*OwnerInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _OwnerInterface_Delete_Handler,
		},
		{
			MethodName: "GetDeeds",
			Handler:    _OwnerInterface_GetDeeds_Handler,
		},
		{
			MethodName: "GetHosts",
			Handler:    _OwnerInterface_GetHosts_Handler,
		},
		{
			MethodName: "GetOwner",
			Handler:    _OwnerInterface_GetOwner_Handler,
		},
		{
			MethodName: "SetShow",
			Handler:    _OwnerInterface_SetShow_Handler,
		},
		{
			MethodName: "TakeOwnership",
			Handler:    _OwnerInterface_TakeOwnership_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/host.proto",
}

const (
	ProcInterface_ClearRedirect_FullMethodName   = "/host.ProcInterface/ClearRedirect"
	ProcInterface_GetFrame_FullMethodName        = "/host.ProcInterface/GetFrame"
	ProcInterface_GetHost_FullMethodName         = "/host.ProcInterface/GetHost"
	ProcInterface_GetJob_FullMethodName          = "/host.ProcInterface/GetJob"
	ProcInterface_GetLayer_FullMethodName        = "/host.ProcInterface/GetLayer"
	ProcInterface_GetProcs_FullMethodName        = "/host.ProcInterface/GetProcs"
	ProcInterface_Kill_FullMethodName            = "/host.ProcInterface/Kill"
	ProcInterface_RedirectToGroup_FullMethodName = "/host.ProcInterface/RedirectToGroup"
	ProcInterface_RedirectToJob_FullMethodName   = "/host.ProcInterface/RedirectToJob"
	ProcInterface_Unbook_FullMethodName          = "/host.ProcInterface/Unbook"
	ProcInterface_UnbookProcs_FullMethodName     = "/host.ProcInterface/UnbookProcs"
	ProcInterface_UnbookToGroup_FullMethodName   = "/host.ProcInterface/UnbookToGroup"
	ProcInterface_UnbookToJob_FullMethodName     = "/host.ProcInterface/UnbookToJob"
)

// ProcInterfaceClient is the client API for ProcInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcInterfaceClient interface {
	// Clears the redirect off of the proc so it dispatches naturally.
	ClearRedirect(ctx context.Context, in *ProcClearRedirectRequest, opts ...grpc.CallOption) (*ProcClearRedirectResponse, error)
	// Returns the [Frame] running on the [Proc]
	GetFrame(ctx context.Context, in *ProcGetFrameRequest, opts ...grpc.CallOption) (*ProcGetFrameResponse, error)
	// Returns the [Host] this [Proc] was allocated from.
	GetHost(ctx context.Context, in *ProcGetHostRequest, opts ...grpc.CallOption) (*ProcGetHostResponse, error)
	// Returns the [Job] the [Proc] has been assigned to.
	GetJob(ctx context.Context, in *ProcGetJobRequest, opts ...grpc.CallOption) (*ProcGetJobResponse, error)
	// Returns the [Layer] the [Proc] has been assigned to.
	GetLayer(ctx context.Context, in *ProcGetLayerRequest, opts ...grpc.CallOption) (*ProcGetLayerResponse, error)
	// Return a list of procs matching the search
	GetProcs(ctx context.Context, in *ProcGetProcsRequest, opts ...grpc.CallOption) (*ProcGetProcsResponse, error)
	// Sends a kill signal to the running process.
	Kill(ctx context.Context, in *ProcKillRequest, opts ...grpc.CallOption) (*ProcKillResponse, error)
	// Unbooks and redriects the proc to the specified group.  Optionally kills the proc immediately.  Will overwrite an
	// existing redirect. Return true if the redirect was a success. The redirect would fail in the event that the
	// specified group does not have a suitable frame for the proc.
	RedirectToGroup(ctx context.Context, in *ProcRedirectToGroupRequest, opts ...grpc.CallOption) (*ProcRedirectToGroupResponse, error)
	// Unbooks and redriects the proc to the specified job.  Optionally kills the proc immediately.  Will overwrite an
	// existing redirect. Return true if the redirect was a success. The redirect would fail in the event th
	RedirectToJob(ctx context.Context, in *ProcRedirectToJobRequest, opts ...grpc.CallOption) (*ProcRedirectToJobResponse, error)
	// Unbooks this [Proc].  Unbooking means the [Proc] will automatically seek out a new [Job] when the current
	// [Frame] is complete.
	Unbook(ctx context.Context, in *ProcUnbookRequest, opts ...grpc.CallOption) (*ProcUnbookResponse, error)
	// Unbooks procs that match the ProcSearchCriteria.  This request can span jobs, shows, allocations, hosts etc.
	// Set kill to true if the running frames should immediately be killed.
	UnbookProcs(ctx context.Context, in *ProcUnbookProcsRequest, opts ...grpc.CallOption) (*ProcUnbookProcsResponse, error)
	// Unbooks procs that match the ProcSearchCriteria and books them on the specified group, assuming the group has
	// layers that can take the procs. If the kill boolean is set to true, the operation happens immediately. If false,
	// the proc will move after it finishes its current frame.
	UnbookToGroup(ctx context.Context, in *ProcUnbookToGroupRequest, opts ...grpc.CallOption) (*ProcUnbookToGroupResponse, error)
	// Unbooks procs that match the ProcSearchCriteria and books them on the specified list of jobs, assuming those jobs
	// have layers that can take the procs. If the kill boolean is set to true, the operation happens immediately. If
	// false, the proc will move after it finishes its current frame.
	UnbookToJob(ctx context.Context, in *ProcUnbookToJobRequest, opts ...grpc.CallOption) (*ProcUnbookToJobResponse, error)
}

type procInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewProcInterfaceClient(cc grpc.ClientConnInterface) ProcInterfaceClient {
	return &procInterfaceClient{cc}
}

func (c *procInterfaceClient) ClearRedirect(ctx context.Context, in *ProcClearRedirectRequest, opts ...grpc.CallOption) (*ProcClearRedirectResponse, error) {
	out := new(ProcClearRedirectResponse)
	err := c.cc.Invoke(ctx, ProcInterface_ClearRedirect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) GetFrame(ctx context.Context, in *ProcGetFrameRequest, opts ...grpc.CallOption) (*ProcGetFrameResponse, error) {
	out := new(ProcGetFrameResponse)
	err := c.cc.Invoke(ctx, ProcInterface_GetFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) GetHost(ctx context.Context, in *ProcGetHostRequest, opts ...grpc.CallOption) (*ProcGetHostResponse, error) {
	out := new(ProcGetHostResponse)
	err := c.cc.Invoke(ctx, ProcInterface_GetHost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) GetJob(ctx context.Context, in *ProcGetJobRequest, opts ...grpc.CallOption) (*ProcGetJobResponse, error) {
	out := new(ProcGetJobResponse)
	err := c.cc.Invoke(ctx, ProcInterface_GetJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) GetLayer(ctx context.Context, in *ProcGetLayerRequest, opts ...grpc.CallOption) (*ProcGetLayerResponse, error) {
	out := new(ProcGetLayerResponse)
	err := c.cc.Invoke(ctx, ProcInterface_GetLayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) GetProcs(ctx context.Context, in *ProcGetProcsRequest, opts ...grpc.CallOption) (*ProcGetProcsResponse, error) {
	out := new(ProcGetProcsResponse)
	err := c.cc.Invoke(ctx, ProcInterface_GetProcs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) Kill(ctx context.Context, in *ProcKillRequest, opts ...grpc.CallOption) (*ProcKillResponse, error) {
	out := new(ProcKillResponse)
	err := c.cc.Invoke(ctx, ProcInterface_Kill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) RedirectToGroup(ctx context.Context, in *ProcRedirectToGroupRequest, opts ...grpc.CallOption) (*ProcRedirectToGroupResponse, error) {
	out := new(ProcRedirectToGroupResponse)
	err := c.cc.Invoke(ctx, ProcInterface_RedirectToGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) RedirectToJob(ctx context.Context, in *ProcRedirectToJobRequest, opts ...grpc.CallOption) (*ProcRedirectToJobResponse, error) {
	out := new(ProcRedirectToJobResponse)
	err := c.cc.Invoke(ctx, ProcInterface_RedirectToJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) Unbook(ctx context.Context, in *ProcUnbookRequest, opts ...grpc.CallOption) (*ProcUnbookResponse, error) {
	out := new(ProcUnbookResponse)
	err := c.cc.Invoke(ctx, ProcInterface_Unbook_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) UnbookProcs(ctx context.Context, in *ProcUnbookProcsRequest, opts ...grpc.CallOption) (*ProcUnbookProcsResponse, error) {
	out := new(ProcUnbookProcsResponse)
	err := c.cc.Invoke(ctx, ProcInterface_UnbookProcs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) UnbookToGroup(ctx context.Context, in *ProcUnbookToGroupRequest, opts ...grpc.CallOption) (*ProcUnbookToGroupResponse, error) {
	out := new(ProcUnbookToGroupResponse)
	err := c.cc.Invoke(ctx, ProcInterface_UnbookToGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *procInterfaceClient) UnbookToJob(ctx context.Context, in *ProcUnbookToJobRequest, opts ...grpc.CallOption) (*ProcUnbookToJobResponse, error) {
	out := new(ProcUnbookToJobResponse)
	err := c.cc.Invoke(ctx, ProcInterface_UnbookToJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcInterfaceServer is the server API for ProcInterface service.
// All implementations must embed UnimplementedProcInterfaceServer
// for forward compatibility
type ProcInterfaceServer interface {
	// Clears the redirect off of the proc so it dispatches naturally.
	ClearRedirect(context.Context, *ProcClearRedirectRequest) (*ProcClearRedirectResponse, error)
	// Returns the [Frame] running on the [Proc]
	GetFrame(context.Context, *ProcGetFrameRequest) (*ProcGetFrameResponse, error)
	// Returns the [Host] this [Proc] was allocated from.
	GetHost(context.Context, *ProcGetHostRequest) (*ProcGetHostResponse, error)
	// Returns the [Job] the [Proc] has been assigned to.
	GetJob(context.Context, *ProcGetJobRequest) (*ProcGetJobResponse, error)
	// Returns the [Layer] the [Proc] has been assigned to.
	GetLayer(context.Context, *ProcGetLayerRequest) (*ProcGetLayerResponse, error)
	// Return a list of procs matching the search
	GetProcs(context.Context, *ProcGetProcsRequest) (*ProcGetProcsResponse, error)
	// Sends a kill signal to the running process.
	Kill(context.Context, *ProcKillRequest) (*ProcKillResponse, error)
	// Unbooks and redriects the proc to the specified group.  Optionally kills the proc immediately.  Will overwrite an
	// existing redirect. Return true if the redirect was a success. The redirect would fail in the event that the
	// specified group does not have a suitable frame for the proc.
	RedirectToGroup(context.Context, *ProcRedirectToGroupRequest) (*ProcRedirectToGroupResponse, error)
	// Unbooks and redriects the proc to the specified job.  Optionally kills the proc immediately.  Will overwrite an
	// existing redirect. Return true if the redirect was a success. The redirect would fail in the event th
	RedirectToJob(context.Context, *ProcRedirectToJobRequest) (*ProcRedirectToJobResponse, error)
	// Unbooks this [Proc].  Unbooking means the [Proc] will automatically seek out a new [Job] when the current
	// [Frame] is complete.
	Unbook(context.Context, *ProcUnbookRequest) (*ProcUnbookResponse, error)
	// Unbooks procs that match the ProcSearchCriteria.  This request can span jobs, shows, allocations, hosts etc.
	// Set kill to true if the running frames should immediately be killed.
	UnbookProcs(context.Context, *ProcUnbookProcsRequest) (*ProcUnbookProcsResponse, error)
	// Unbooks procs that match the ProcSearchCriteria and books them on the specified group, assuming the group has
	// layers that can take the procs. If the kill boolean is set to true, the operation happens immediately. If false,
	// the proc will move after it finishes its current frame.
	UnbookToGroup(context.Context, *ProcUnbookToGroupRequest) (*ProcUnbookToGroupResponse, error)
	// Unbooks procs that match the ProcSearchCriteria and books them on the specified list of jobs, assuming those jobs
	// have layers that can take the procs. If the kill boolean is set to true, the operation happens immediately. If
	// false, the proc will move after it finishes its current frame.
	UnbookToJob(context.Context, *ProcUnbookToJobRequest) (*ProcUnbookToJobResponse, error)
	mustEmbedUnimplementedProcInterfaceServer()
}

// UnimplementedProcInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedProcInterfaceServer struct {
}

func (UnimplementedProcInterfaceServer) ClearRedirect(context.Context, *ProcClearRedirectRequest) (*ProcClearRedirectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearRedirect not implemented")
}
func (UnimplementedProcInterfaceServer) GetFrame(context.Context, *ProcGetFrameRequest) (*ProcGetFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFrame not implemented")
}
func (UnimplementedProcInterfaceServer) GetHost(context.Context, *ProcGetHostRequest) (*ProcGetHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHost not implemented")
}
func (UnimplementedProcInterfaceServer) GetJob(context.Context, *ProcGetJobRequest) (*ProcGetJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedProcInterfaceServer) GetLayer(context.Context, *ProcGetLayerRequest) (*ProcGetLayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLayer not implemented")
}
func (UnimplementedProcInterfaceServer) GetProcs(context.Context, *ProcGetProcsRequest) (*ProcGetProcsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcs not implemented")
}
func (UnimplementedProcInterfaceServer) Kill(context.Context, *ProcKillRequest) (*ProcKillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedProcInterfaceServer) RedirectToGroup(context.Context, *ProcRedirectToGroupRequest) (*ProcRedirectToGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectToGroup not implemented")
}
func (UnimplementedProcInterfaceServer) RedirectToJob(context.Context, *ProcRedirectToJobRequest) (*ProcRedirectToJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RedirectToJob not implemented")
}
func (UnimplementedProcInterfaceServer) Unbook(context.Context, *ProcUnbookRequest) (*ProcUnbookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unbook not implemented")
}
func (UnimplementedProcInterfaceServer) UnbookProcs(context.Context, *ProcUnbookProcsRequest) (*ProcUnbookProcsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbookProcs not implemented")
}
func (UnimplementedProcInterfaceServer) UnbookToGroup(context.Context, *ProcUnbookToGroupRequest) (*ProcUnbookToGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbookToGroup not implemented")
}
func (UnimplementedProcInterfaceServer) UnbookToJob(context.Context, *ProcUnbookToJobRequest) (*ProcUnbookToJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbookToJob not implemented")
}
func (UnimplementedProcInterfaceServer) mustEmbedUnimplementedProcInterfaceServer() {}

// UnsafeProcInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcInterfaceServer will
// result in compilation errors.
type UnsafeProcInterfaceServer interface {
	mustEmbedUnimplementedProcInterfaceServer()
}

func RegisterProcInterfaceServer(s grpc.ServiceRegistrar, srv ProcInterfaceServer) {
	s.RegisterService(&ProcInterface_ServiceDesc, srv)
}

func _ProcInterface_ClearRedirect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcClearRedirectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).ClearRedirect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_ClearRedirect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).ClearRedirect(ctx, req.(*ProcClearRedirectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_GetFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcGetFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).GetFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_GetFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).GetFrame(ctx, req.(*ProcGetFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_GetHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcGetHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).GetHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_GetHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).GetHost(ctx, req.(*ProcGetHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcGetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_GetJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).GetJob(ctx, req.(*ProcGetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_GetLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcGetLayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).GetLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_GetLayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).GetLayer(ctx, req.(*ProcGetLayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_GetProcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcGetProcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).GetProcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_GetProcs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).GetProcs(ctx, req.(*ProcGetProcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcKillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).Kill(ctx, req.(*ProcKillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_RedirectToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcRedirectToGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).RedirectToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_RedirectToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).RedirectToGroup(ctx, req.(*ProcRedirectToGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_RedirectToJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcRedirectToJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).RedirectToJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_RedirectToJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).RedirectToJob(ctx, req.(*ProcRedirectToJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_Unbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcUnbookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).Unbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_Unbook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).Unbook(ctx, req.(*ProcUnbookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_UnbookProcs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcUnbookProcsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).UnbookProcs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_UnbookProcs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).UnbookProcs(ctx, req.(*ProcUnbookProcsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_UnbookToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcUnbookToGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).UnbookToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_UnbookToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).UnbookToGroup(ctx, req.(*ProcUnbookToGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcInterface_UnbookToJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcUnbookToJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcInterfaceServer).UnbookToJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcInterface_UnbookToJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcInterfaceServer).UnbookToJob(ctx, req.(*ProcUnbookToJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcInterface_ServiceDesc is the grpc.ServiceDesc for ProcInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "host.ProcInterface",
	HandlerType: (*ProcInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ClearRedirect",
			Handler:    _ProcInterface_ClearRedirect_Handler,
		},
		{
			MethodName: "GetFrame",
			Handler:    _ProcInterface_GetFrame_Handler,
		},
		{
			MethodName: "GetHost",
			Handler:    _ProcInterface_GetHost_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _ProcInterface_GetJob_Handler,
		},
		{
			MethodName: "GetLayer",
			Handler:    _ProcInterface_GetLayer_Handler,
		},
		{
			MethodName: "GetProcs",
			Handler:    _ProcInterface_GetProcs_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _ProcInterface_Kill_Handler,
		},
		{
			MethodName: "RedirectToGroup",
			Handler:    _ProcInterface_RedirectToGroup_Handler,
		},
		{
			MethodName: "RedirectToJob",
			Handler:    _ProcInterface_RedirectToJob_Handler,
		},
		{
			MethodName: "Unbook",
			Handler:    _ProcInterface_Unbook_Handler,
		},
		{
			MethodName: "UnbookProcs",
			Handler:    _ProcInterface_UnbookProcs_Handler,
		},
		{
			MethodName: "UnbookToGroup",
			Handler:    _ProcInterface_UnbookToGroup_Handler,
		},
		{
			MethodName: "UnbookToJob",
			Handler:    _ProcInterface_UnbookToJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/host.proto",
}
