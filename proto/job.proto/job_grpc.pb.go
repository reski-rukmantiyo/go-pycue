// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: OpenCue/proto/job.proto

package job_proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	FrameInterface_AddRenderPartition_FullMethodName      = "/job.FrameInterface/AddRenderPartition"
	FrameInterface_CreateDependencyOnFrame_FullMethodName = "/job.FrameInterface/CreateDependencyOnFrame"
	FrameInterface_CreateDependencyOnJob_FullMethodName   = "/job.FrameInterface/CreateDependencyOnJob"
	FrameInterface_CreateDependencyOnLayer_FullMethodName = "/job.FrameInterface/CreateDependencyOnLayer"
	FrameInterface_DropDepends_FullMethodName             = "/job.FrameInterface/DropDepends"
	FrameInterface_Eat_FullMethodName                     = "/job.FrameInterface/Eat"
	FrameInterface_FindFrame_FullMethodName               = "/job.FrameInterface/FindFrame"
	FrameInterface_GetFrame_FullMethodName                = "/job.FrameInterface/GetFrame"
	FrameInterface_GetFrames_FullMethodName               = "/job.FrameInterface/GetFrames"
	FrameInterface_GetWhatDependsOnThis_FullMethodName    = "/job.FrameInterface/GetWhatDependsOnThis"
	FrameInterface_GetWhatThisDependsOn_FullMethodName    = "/job.FrameInterface/GetWhatThisDependsOn"
	FrameInterface_Kill_FullMethodName                    = "/job.FrameInterface/Kill"
	FrameInterface_MarkAsDepend_FullMethodName            = "/job.FrameInterface/MarkAsDepend"
	FrameInterface_MarkAsWaiting_FullMethodName           = "/job.FrameInterface/MarkAsWaiting"
	FrameInterface_Retry_FullMethodName                   = "/job.FrameInterface/Retry"
	FrameInterface_SetCheckpointState_FullMethodName      = "/job.FrameInterface/SetCheckpointState"
)

// FrameInterfaceClient is the client API for FrameInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FrameInterfaceClient interface {
	// Add a render partition to the frame.
	AddRenderPartition(ctx context.Context, in *FrameAddRenderPartitionRequest, opts ...grpc.CallOption) (*FrameAddRenderPartitionResponse, error)
	// Sets up and returns a FrameOnFrame dependency.
	CreateDependencyOnFrame(ctx context.Context, in *FrameCreateDependencyOnFrameRequest, opts ...grpc.CallOption) (*FrameCreateDependencyOnFrameResponse, error)
	// Sets up and returns a FrameOnJob dependency.
	CreateDependencyOnJob(ctx context.Context, in *FrameCreateDependencyOnJobRequest, opts ...grpc.CallOption) (*FrameCreateDependencyOnJobResponse, error)
	// Sets up and returns a FrameOnLayer dependency.
	CreateDependencyOnLayer(ctx context.Context, in *FrameCreateDependencyOnLayerRequest, opts ...grpc.CallOption) (*FrameCreateDependencyOnLayerResponse, error)
	// Drops every dependendy that is causing this frame not to run.
	DropDepends(ctx context.Context, in *FrameDropDependsRequest, opts ...grpc.CallOption) (*FrameDropDependsResponse, error)
	// Eating a frame will stop rendering and will not try to coninue processing the frame.
	Eat(ctx context.Context, in *FrameEatRequest, opts ...grpc.CallOption) (*FrameEatResponse, error)
	// Finds a frame in a pending job based on the job, layer, and frame number.
	FindFrame(ctx context.Context, in *FrameFindFrameRequest, opts ...grpc.CallOption) (*FrameFindFrameResponse, error)
	// Get a frame from its unique id
	GetFrame(ctx context.Context, in *FrameGetFrameRequest, opts ...grpc.CallOption) (*FrameGetFrameResponse, error)
	// Get a frame from search criteria
	GetFrames(ctx context.Context, in *FrameGetFramesRequest, opts ...grpc.CallOption) (*FrameGetFramesResponse, error)
	// Returns a list of dependencies setup to depend on this frame.
	GetWhatDependsOnThis(ctx context.Context, in *FrameGetWhatDependsOnThisRequest, opts ...grpc.CallOption) (*FrameGetWhatDependsOnThisResponse, error)
	// Returns a list of dependencies that this frame depends on.
	GetWhatThisDependsOn(ctx context.Context, in *FrameGetWhatThisDependsOnRequest, opts ...grpc.CallOption) (*FrameGetWhatThisDependsOnResponse, error)
	// Kills the frame if it is running
	Kill(ctx context.Context, in *FrameKillRequest, opts ...grpc.CallOption) (*FrameKillResponse, error)
	// Will recount the number of active dependencies on the frame and put it back into the Depend state if that count
	// is greater than 0.
	MarkAsDepend(ctx context.Context, in *FrameMarkAsDependRequest, opts ...grpc.CallOption) (*FrameMarkAsDependResponse, error)
	// Changes the frame's dependency count to 0, which will put the frame into the waiting state.  Retrying the frame
	// will put it back into the waiting state.
	MarkAsWaiting(ctx context.Context, in *FrameMarkAsWaitingRequest, opts ...grpc.CallOption) (*FrameMarkAsWaitingResponse, error)
	// Retries the frame by setting it as waiting
	Retry(ctx context.Context, in *FrameRetryRequest, opts ...grpc.CallOption) (*FrameRetryResponse, error)
	// Updates the state of the frame's checkpoint status.  If the checkpoint status is complete, then the frame's
	// checkpointCoreSeconds is updated with the amount of render time that was checkpointed.
	SetCheckpointState(ctx context.Context, in *FrameSetCheckpointStateRequest, opts ...grpc.CallOption) (*FrameSetCheckpointStateResponse, error)
}

type frameInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewFrameInterfaceClient(cc grpc.ClientConnInterface) FrameInterfaceClient {
	return &frameInterfaceClient{cc}
}

func (c *frameInterfaceClient) AddRenderPartition(ctx context.Context, in *FrameAddRenderPartitionRequest, opts ...grpc.CallOption) (*FrameAddRenderPartitionResponse, error) {
	out := new(FrameAddRenderPartitionResponse)
	err := c.cc.Invoke(ctx, FrameInterface_AddRenderPartition_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) CreateDependencyOnFrame(ctx context.Context, in *FrameCreateDependencyOnFrameRequest, opts ...grpc.CallOption) (*FrameCreateDependencyOnFrameResponse, error) {
	out := new(FrameCreateDependencyOnFrameResponse)
	err := c.cc.Invoke(ctx, FrameInterface_CreateDependencyOnFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) CreateDependencyOnJob(ctx context.Context, in *FrameCreateDependencyOnJobRequest, opts ...grpc.CallOption) (*FrameCreateDependencyOnJobResponse, error) {
	out := new(FrameCreateDependencyOnJobResponse)
	err := c.cc.Invoke(ctx, FrameInterface_CreateDependencyOnJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) CreateDependencyOnLayer(ctx context.Context, in *FrameCreateDependencyOnLayerRequest, opts ...grpc.CallOption) (*FrameCreateDependencyOnLayerResponse, error) {
	out := new(FrameCreateDependencyOnLayerResponse)
	err := c.cc.Invoke(ctx, FrameInterface_CreateDependencyOnLayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) DropDepends(ctx context.Context, in *FrameDropDependsRequest, opts ...grpc.CallOption) (*FrameDropDependsResponse, error) {
	out := new(FrameDropDependsResponse)
	err := c.cc.Invoke(ctx, FrameInterface_DropDepends_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) Eat(ctx context.Context, in *FrameEatRequest, opts ...grpc.CallOption) (*FrameEatResponse, error) {
	out := new(FrameEatResponse)
	err := c.cc.Invoke(ctx, FrameInterface_Eat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) FindFrame(ctx context.Context, in *FrameFindFrameRequest, opts ...grpc.CallOption) (*FrameFindFrameResponse, error) {
	out := new(FrameFindFrameResponse)
	err := c.cc.Invoke(ctx, FrameInterface_FindFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) GetFrame(ctx context.Context, in *FrameGetFrameRequest, opts ...grpc.CallOption) (*FrameGetFrameResponse, error) {
	out := new(FrameGetFrameResponse)
	err := c.cc.Invoke(ctx, FrameInterface_GetFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) GetFrames(ctx context.Context, in *FrameGetFramesRequest, opts ...grpc.CallOption) (*FrameGetFramesResponse, error) {
	out := new(FrameGetFramesResponse)
	err := c.cc.Invoke(ctx, FrameInterface_GetFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) GetWhatDependsOnThis(ctx context.Context, in *FrameGetWhatDependsOnThisRequest, opts ...grpc.CallOption) (*FrameGetWhatDependsOnThisResponse, error) {
	out := new(FrameGetWhatDependsOnThisResponse)
	err := c.cc.Invoke(ctx, FrameInterface_GetWhatDependsOnThis_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) GetWhatThisDependsOn(ctx context.Context, in *FrameGetWhatThisDependsOnRequest, opts ...grpc.CallOption) (*FrameGetWhatThisDependsOnResponse, error) {
	out := new(FrameGetWhatThisDependsOnResponse)
	err := c.cc.Invoke(ctx, FrameInterface_GetWhatThisDependsOn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) Kill(ctx context.Context, in *FrameKillRequest, opts ...grpc.CallOption) (*FrameKillResponse, error) {
	out := new(FrameKillResponse)
	err := c.cc.Invoke(ctx, FrameInterface_Kill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) MarkAsDepend(ctx context.Context, in *FrameMarkAsDependRequest, opts ...grpc.CallOption) (*FrameMarkAsDependResponse, error) {
	out := new(FrameMarkAsDependResponse)
	err := c.cc.Invoke(ctx, FrameInterface_MarkAsDepend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) MarkAsWaiting(ctx context.Context, in *FrameMarkAsWaitingRequest, opts ...grpc.CallOption) (*FrameMarkAsWaitingResponse, error) {
	out := new(FrameMarkAsWaitingResponse)
	err := c.cc.Invoke(ctx, FrameInterface_MarkAsWaiting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) Retry(ctx context.Context, in *FrameRetryRequest, opts ...grpc.CallOption) (*FrameRetryResponse, error) {
	out := new(FrameRetryResponse)
	err := c.cc.Invoke(ctx, FrameInterface_Retry_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frameInterfaceClient) SetCheckpointState(ctx context.Context, in *FrameSetCheckpointStateRequest, opts ...grpc.CallOption) (*FrameSetCheckpointStateResponse, error) {
	out := new(FrameSetCheckpointStateResponse)
	err := c.cc.Invoke(ctx, FrameInterface_SetCheckpointState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FrameInterfaceServer is the server API for FrameInterface service.
// All implementations must embed UnimplementedFrameInterfaceServer
// for forward compatibility
type FrameInterfaceServer interface {
	// Add a render partition to the frame.
	AddRenderPartition(context.Context, *FrameAddRenderPartitionRequest) (*FrameAddRenderPartitionResponse, error)
	// Sets up and returns a FrameOnFrame dependency.
	CreateDependencyOnFrame(context.Context, *FrameCreateDependencyOnFrameRequest) (*FrameCreateDependencyOnFrameResponse, error)
	// Sets up and returns a FrameOnJob dependency.
	CreateDependencyOnJob(context.Context, *FrameCreateDependencyOnJobRequest) (*FrameCreateDependencyOnJobResponse, error)
	// Sets up and returns a FrameOnLayer dependency.
	CreateDependencyOnLayer(context.Context, *FrameCreateDependencyOnLayerRequest) (*FrameCreateDependencyOnLayerResponse, error)
	// Drops every dependendy that is causing this frame not to run.
	DropDepends(context.Context, *FrameDropDependsRequest) (*FrameDropDependsResponse, error)
	// Eating a frame will stop rendering and will not try to coninue processing the frame.
	Eat(context.Context, *FrameEatRequest) (*FrameEatResponse, error)
	// Finds a frame in a pending job based on the job, layer, and frame number.
	FindFrame(context.Context, *FrameFindFrameRequest) (*FrameFindFrameResponse, error)
	// Get a frame from its unique id
	GetFrame(context.Context, *FrameGetFrameRequest) (*FrameGetFrameResponse, error)
	// Get a frame from search criteria
	GetFrames(context.Context, *FrameGetFramesRequest) (*FrameGetFramesResponse, error)
	// Returns a list of dependencies setup to depend on this frame.
	GetWhatDependsOnThis(context.Context, *FrameGetWhatDependsOnThisRequest) (*FrameGetWhatDependsOnThisResponse, error)
	// Returns a list of dependencies that this frame depends on.
	GetWhatThisDependsOn(context.Context, *FrameGetWhatThisDependsOnRequest) (*FrameGetWhatThisDependsOnResponse, error)
	// Kills the frame if it is running
	Kill(context.Context, *FrameKillRequest) (*FrameKillResponse, error)
	// Will recount the number of active dependencies on the frame and put it back into the Depend state if that count
	// is greater than 0.
	MarkAsDepend(context.Context, *FrameMarkAsDependRequest) (*FrameMarkAsDependResponse, error)
	// Changes the frame's dependency count to 0, which will put the frame into the waiting state.  Retrying the frame
	// will put it back into the waiting state.
	MarkAsWaiting(context.Context, *FrameMarkAsWaitingRequest) (*FrameMarkAsWaitingResponse, error)
	// Retries the frame by setting it as waiting
	Retry(context.Context, *FrameRetryRequest) (*FrameRetryResponse, error)
	// Updates the state of the frame's checkpoint status.  If the checkpoint status is complete, then the frame's
	// checkpointCoreSeconds is updated with the amount of render time that was checkpointed.
	SetCheckpointState(context.Context, *FrameSetCheckpointStateRequest) (*FrameSetCheckpointStateResponse, error)
	mustEmbedUnimplementedFrameInterfaceServer()
}

// UnimplementedFrameInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedFrameInterfaceServer struct {
}

func (UnimplementedFrameInterfaceServer) AddRenderPartition(context.Context, *FrameAddRenderPartitionRequest) (*FrameAddRenderPartitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRenderPartition not implemented")
}
func (UnimplementedFrameInterfaceServer) CreateDependencyOnFrame(context.Context, *FrameCreateDependencyOnFrameRequest) (*FrameCreateDependencyOnFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnFrame not implemented")
}
func (UnimplementedFrameInterfaceServer) CreateDependencyOnJob(context.Context, *FrameCreateDependencyOnJobRequest) (*FrameCreateDependencyOnJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnJob not implemented")
}
func (UnimplementedFrameInterfaceServer) CreateDependencyOnLayer(context.Context, *FrameCreateDependencyOnLayerRequest) (*FrameCreateDependencyOnLayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnLayer not implemented")
}
func (UnimplementedFrameInterfaceServer) DropDepends(context.Context, *FrameDropDependsRequest) (*FrameDropDependsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropDepends not implemented")
}
func (UnimplementedFrameInterfaceServer) Eat(context.Context, *FrameEatRequest) (*FrameEatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Eat not implemented")
}
func (UnimplementedFrameInterfaceServer) FindFrame(context.Context, *FrameFindFrameRequest) (*FrameFindFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindFrame not implemented")
}
func (UnimplementedFrameInterfaceServer) GetFrame(context.Context, *FrameGetFrameRequest) (*FrameGetFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFrame not implemented")
}
func (UnimplementedFrameInterfaceServer) GetFrames(context.Context, *FrameGetFramesRequest) (*FrameGetFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFrames not implemented")
}
func (UnimplementedFrameInterfaceServer) GetWhatDependsOnThis(context.Context, *FrameGetWhatDependsOnThisRequest) (*FrameGetWhatDependsOnThisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWhatDependsOnThis not implemented")
}
func (UnimplementedFrameInterfaceServer) GetWhatThisDependsOn(context.Context, *FrameGetWhatThisDependsOnRequest) (*FrameGetWhatThisDependsOnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWhatThisDependsOn not implemented")
}
func (UnimplementedFrameInterfaceServer) Kill(context.Context, *FrameKillRequest) (*FrameKillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedFrameInterfaceServer) MarkAsDepend(context.Context, *FrameMarkAsDependRequest) (*FrameMarkAsDependResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAsDepend not implemented")
}
func (UnimplementedFrameInterfaceServer) MarkAsWaiting(context.Context, *FrameMarkAsWaitingRequest) (*FrameMarkAsWaitingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAsWaiting not implemented")
}
func (UnimplementedFrameInterfaceServer) Retry(context.Context, *FrameRetryRequest) (*FrameRetryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retry not implemented")
}
func (UnimplementedFrameInterfaceServer) SetCheckpointState(context.Context, *FrameSetCheckpointStateRequest) (*FrameSetCheckpointStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCheckpointState not implemented")
}
func (UnimplementedFrameInterfaceServer) mustEmbedUnimplementedFrameInterfaceServer() {}

// UnsafeFrameInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FrameInterfaceServer will
// result in compilation errors.
type UnsafeFrameInterfaceServer interface {
	mustEmbedUnimplementedFrameInterfaceServer()
}

func RegisterFrameInterfaceServer(s grpc.ServiceRegistrar, srv FrameInterfaceServer) {
	s.RegisterService(&FrameInterface_ServiceDesc, srv)
}

func _FrameInterface_AddRenderPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameAddRenderPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).AddRenderPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_AddRenderPartition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).AddRenderPartition(ctx, req.(*FrameAddRenderPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_CreateDependencyOnFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameCreateDependencyOnFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).CreateDependencyOnFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_CreateDependencyOnFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).CreateDependencyOnFrame(ctx, req.(*FrameCreateDependencyOnFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_CreateDependencyOnJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameCreateDependencyOnJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).CreateDependencyOnJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_CreateDependencyOnJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).CreateDependencyOnJob(ctx, req.(*FrameCreateDependencyOnJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_CreateDependencyOnLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameCreateDependencyOnLayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).CreateDependencyOnLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_CreateDependencyOnLayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).CreateDependencyOnLayer(ctx, req.(*FrameCreateDependencyOnLayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_DropDepends_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameDropDependsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).DropDepends(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_DropDepends_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).DropDepends(ctx, req.(*FrameDropDependsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_Eat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameEatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).Eat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_Eat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).Eat(ctx, req.(*FrameEatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_FindFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameFindFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).FindFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_FindFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).FindFrame(ctx, req.(*FrameFindFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_GetFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameGetFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).GetFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_GetFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).GetFrame(ctx, req.(*FrameGetFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_GetFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameGetFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).GetFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_GetFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).GetFrames(ctx, req.(*FrameGetFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_GetWhatDependsOnThis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameGetWhatDependsOnThisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).GetWhatDependsOnThis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_GetWhatDependsOnThis_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).GetWhatDependsOnThis(ctx, req.(*FrameGetWhatDependsOnThisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_GetWhatThisDependsOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameGetWhatThisDependsOnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).GetWhatThisDependsOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_GetWhatThisDependsOn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).GetWhatThisDependsOn(ctx, req.(*FrameGetWhatThisDependsOnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameKillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).Kill(ctx, req.(*FrameKillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_MarkAsDepend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameMarkAsDependRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).MarkAsDepend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_MarkAsDepend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).MarkAsDepend(ctx, req.(*FrameMarkAsDependRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_MarkAsWaiting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameMarkAsWaitingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).MarkAsWaiting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_MarkAsWaiting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).MarkAsWaiting(ctx, req.(*FrameMarkAsWaitingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_Retry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameRetryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).Retry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_Retry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).Retry(ctx, req.(*FrameRetryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FrameInterface_SetCheckpointState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameSetCheckpointStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrameInterfaceServer).SetCheckpointState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FrameInterface_SetCheckpointState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrameInterfaceServer).SetCheckpointState(ctx, req.(*FrameSetCheckpointStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FrameInterface_ServiceDesc is the grpc.ServiceDesc for FrameInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FrameInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "job.FrameInterface",
	HandlerType: (*FrameInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRenderPartition",
			Handler:    _FrameInterface_AddRenderPartition_Handler,
		},
		{
			MethodName: "CreateDependencyOnFrame",
			Handler:    _FrameInterface_CreateDependencyOnFrame_Handler,
		},
		{
			MethodName: "CreateDependencyOnJob",
			Handler:    _FrameInterface_CreateDependencyOnJob_Handler,
		},
		{
			MethodName: "CreateDependencyOnLayer",
			Handler:    _FrameInterface_CreateDependencyOnLayer_Handler,
		},
		{
			MethodName: "DropDepends",
			Handler:    _FrameInterface_DropDepends_Handler,
		},
		{
			MethodName: "Eat",
			Handler:    _FrameInterface_Eat_Handler,
		},
		{
			MethodName: "FindFrame",
			Handler:    _FrameInterface_FindFrame_Handler,
		},
		{
			MethodName: "GetFrame",
			Handler:    _FrameInterface_GetFrame_Handler,
		},
		{
			MethodName: "GetFrames",
			Handler:    _FrameInterface_GetFrames_Handler,
		},
		{
			MethodName: "GetWhatDependsOnThis",
			Handler:    _FrameInterface_GetWhatDependsOnThis_Handler,
		},
		{
			MethodName: "GetWhatThisDependsOn",
			Handler:    _FrameInterface_GetWhatThisDependsOn_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _FrameInterface_Kill_Handler,
		},
		{
			MethodName: "MarkAsDepend",
			Handler:    _FrameInterface_MarkAsDepend_Handler,
		},
		{
			MethodName: "MarkAsWaiting",
			Handler:    _FrameInterface_MarkAsWaiting_Handler,
		},
		{
			MethodName: "Retry",
			Handler:    _FrameInterface_Retry_Handler,
		},
		{
			MethodName: "SetCheckpointState",
			Handler:    _FrameInterface_SetCheckpointState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/job.proto",
}

const (
	GroupInterface_CreateSubGroup_FullMethodName        = "/job.GroupInterface/CreateSubGroup"
	GroupInterface_Delete_FullMethodName                = "/job.GroupInterface/Delete"
	GroupInterface_FindGroup_FullMethodName             = "/job.GroupInterface/FindGroup"
	GroupInterface_GetGroup_FullMethodName              = "/job.GroupInterface/GetGroup"
	GroupInterface_GetGroups_FullMethodName             = "/job.GroupInterface/GetGroups"
	GroupInterface_GetJobs_FullMethodName               = "/job.GroupInterface/GetJobs"
	GroupInterface_ReparentGroups_FullMethodName        = "/job.GroupInterface/ReparentGroups"
	GroupInterface_ReparentJobs_FullMethodName          = "/job.GroupInterface/ReparentJobs"
	GroupInterface_SetDefaultJobMaxCores_FullMethodName = "/job.GroupInterface/SetDefaultJobMaxCores"
	GroupInterface_SetDefaultJobMinCores_FullMethodName = "/job.GroupInterface/SetDefaultJobMinCores"
	GroupInterface_SetDefaultJobMaxGpus_FullMethodName  = "/job.GroupInterface/SetDefaultJobMaxGpus"
	GroupInterface_SetDefaultJobMinGpus_FullMethodName  = "/job.GroupInterface/SetDefaultJobMinGpus"
	GroupInterface_SetDefaultJobPriority_FullMethodName = "/job.GroupInterface/SetDefaultJobPriority"
	GroupInterface_SetDepartment_FullMethodName         = "/job.GroupInterface/SetDepartment"
	GroupInterface_SetGroup_FullMethodName              = "/job.GroupInterface/SetGroup"
	GroupInterface_SetMaxCores_FullMethodName           = "/job.GroupInterface/SetMaxCores"
	GroupInterface_SetMinCores_FullMethodName           = "/job.GroupInterface/SetMinCores"
	GroupInterface_SetMaxGpus_FullMethodName            = "/job.GroupInterface/SetMaxGpus"
	GroupInterface_SetMinGpus_FullMethodName            = "/job.GroupInterface/SetMinGpus"
	GroupInterface_SetName_FullMethodName               = "/job.GroupInterface/SetName"
)

// GroupInterfaceClient is the client API for GroupInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroupInterfaceClient interface {
	// Create a new sub group of the given name
	CreateSubGroup(ctx context.Context, in *GroupCreateSubGroupRequest, opts ...grpc.CallOption) (*GroupCreateSubGroupResponse, error)
	// Delete the provided group
	Delete(ctx context.Context, in *GroupDeleteRequest, opts ...grpc.CallOption) (*GroupDeleteResponse, error)
	// Finds a group by show name and group
	FindGroup(ctx context.Context, in *GroupFindGroupRequest, opts ...grpc.CallOption) (*GroupFindGroupResponse, error)
	// Gets a group by its id
	GetGroup(ctx context.Context, in *GroupGetGroupRequest, opts ...grpc.CallOption) (*GroupGetGroupResponse, error)
	// Get child groups of the provided group
	GetGroups(ctx context.Context, in *GroupGetGroupsRequest, opts ...grpc.CallOption) (*GroupGetGroupsResponse, error)
	// Get Jobs of the provided group
	GetJobs(ctx context.Context, in *GroupGetJobsRequest, opts ...grpc.CallOption) (*GroupGetJobsResponse, error)
	// Reparent the provided groups to the provided group
	ReparentGroups(ctx context.Context, in *GroupReparentGroupsRequest, opts ...grpc.CallOption) (*GroupReparentGroupsResponse, error)
	// Reparent the provided jobs to the provided group
	ReparentJobs(ctx context.Context, in *GroupReparentJobsRequest, opts ...grpc.CallOption) (*GroupReparentJobsResponse, error)
	// Set the Default Job Max Core values to all in the provided group
	SetDefaultJobMaxCores(ctx context.Context, in *GroupSetDefJobMaxCoresRequest, opts ...grpc.CallOption) (*GroupSetDefJobMaxCoresResponse, error)
	// Set the Default Job Min Core values to all in the provided group
	SetDefaultJobMinCores(ctx context.Context, in *GroupSetDefJobMinCoresRequest, opts ...grpc.CallOption) (*GroupSetDefJobMinCoresResponse, error)
	// Set the Default Job Max Gpu values to all in the provided group
	SetDefaultJobMaxGpus(ctx context.Context, in *GroupSetDefJobMaxGpusRequest, opts ...grpc.CallOption) (*GroupSetDefJobMaxGpusResponse, error)
	// Set the Default Job Min Gpu values to all in the provided group
	SetDefaultJobMinGpus(ctx context.Context, in *GroupSetDefJobMinGpusRequest, opts ...grpc.CallOption) (*GroupSetDefJobMinGpusResponse, error)
	// Set the Default Job Priority values to all in the provided group
	SetDefaultJobPriority(ctx context.Context, in *GroupSetDefJobPriorityRequest, opts ...grpc.CallOption) (*GroupSetDefJobPriorityResponse, error)
	// Set the department associated with the provided group
	SetDepartment(ctx context.Context, in *GroupSetDeptRequest, opts ...grpc.CallOption) (*GroupSetDeptResponse, error)
	// Set the provided groups parent group
	SetGroup(ctx context.Context, in *GroupSetGroupRequest, opts ...grpc.CallOption) (*GroupSetGroupResponse, error)
	// Set the group's Max Cores value
	SetMaxCores(ctx context.Context, in *GroupSetMaxCoresRequest, opts ...grpc.CallOption) (*GroupSetMaxCoresResponse, error)
	// Set the groups Min Cores values
	SetMinCores(ctx context.Context, in *GroupSetMinCoresRequest, opts ...grpc.CallOption) (*GroupSetMinCoresResponse, error)
	// Set the group's Max Gpu value
	SetMaxGpus(ctx context.Context, in *GroupSetMaxGpusRequest, opts ...grpc.CallOption) (*GroupSetMaxGpusResponse, error)
	// Set the groups Min Gpu values
	SetMinGpus(ctx context.Context, in *GroupSetMinGpusRequest, opts ...grpc.CallOption) (*GroupSetMinGpusResponse, error)
	// Set the groups name
	SetName(ctx context.Context, in *GroupSetNameRequest, opts ...grpc.CallOption) (*GroupSetNameResponse, error)
}

type groupInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupInterfaceClient(cc grpc.ClientConnInterface) GroupInterfaceClient {
	return &groupInterfaceClient{cc}
}

func (c *groupInterfaceClient) CreateSubGroup(ctx context.Context, in *GroupCreateSubGroupRequest, opts ...grpc.CallOption) (*GroupCreateSubGroupResponse, error) {
	out := new(GroupCreateSubGroupResponse)
	err := c.cc.Invoke(ctx, GroupInterface_CreateSubGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) Delete(ctx context.Context, in *GroupDeleteRequest, opts ...grpc.CallOption) (*GroupDeleteResponse, error) {
	out := new(GroupDeleteResponse)
	err := c.cc.Invoke(ctx, GroupInterface_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) FindGroup(ctx context.Context, in *GroupFindGroupRequest, opts ...grpc.CallOption) (*GroupFindGroupResponse, error) {
	out := new(GroupFindGroupResponse)
	err := c.cc.Invoke(ctx, GroupInterface_FindGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) GetGroup(ctx context.Context, in *GroupGetGroupRequest, opts ...grpc.CallOption) (*GroupGetGroupResponse, error) {
	out := new(GroupGetGroupResponse)
	err := c.cc.Invoke(ctx, GroupInterface_GetGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) GetGroups(ctx context.Context, in *GroupGetGroupsRequest, opts ...grpc.CallOption) (*GroupGetGroupsResponse, error) {
	out := new(GroupGetGroupsResponse)
	err := c.cc.Invoke(ctx, GroupInterface_GetGroups_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) GetJobs(ctx context.Context, in *GroupGetJobsRequest, opts ...grpc.CallOption) (*GroupGetJobsResponse, error) {
	out := new(GroupGetJobsResponse)
	err := c.cc.Invoke(ctx, GroupInterface_GetJobs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) ReparentGroups(ctx context.Context, in *GroupReparentGroupsRequest, opts ...grpc.CallOption) (*GroupReparentGroupsResponse, error) {
	out := new(GroupReparentGroupsResponse)
	err := c.cc.Invoke(ctx, GroupInterface_ReparentGroups_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) ReparentJobs(ctx context.Context, in *GroupReparentJobsRequest, opts ...grpc.CallOption) (*GroupReparentJobsResponse, error) {
	out := new(GroupReparentJobsResponse)
	err := c.cc.Invoke(ctx, GroupInterface_ReparentJobs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetDefaultJobMaxCores(ctx context.Context, in *GroupSetDefJobMaxCoresRequest, opts ...grpc.CallOption) (*GroupSetDefJobMaxCoresResponse, error) {
	out := new(GroupSetDefJobMaxCoresResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetDefaultJobMaxCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetDefaultJobMinCores(ctx context.Context, in *GroupSetDefJobMinCoresRequest, opts ...grpc.CallOption) (*GroupSetDefJobMinCoresResponse, error) {
	out := new(GroupSetDefJobMinCoresResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetDefaultJobMinCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetDefaultJobMaxGpus(ctx context.Context, in *GroupSetDefJobMaxGpusRequest, opts ...grpc.CallOption) (*GroupSetDefJobMaxGpusResponse, error) {
	out := new(GroupSetDefJobMaxGpusResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetDefaultJobMaxGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetDefaultJobMinGpus(ctx context.Context, in *GroupSetDefJobMinGpusRequest, opts ...grpc.CallOption) (*GroupSetDefJobMinGpusResponse, error) {
	out := new(GroupSetDefJobMinGpusResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetDefaultJobMinGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetDefaultJobPriority(ctx context.Context, in *GroupSetDefJobPriorityRequest, opts ...grpc.CallOption) (*GroupSetDefJobPriorityResponse, error) {
	out := new(GroupSetDefJobPriorityResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetDefaultJobPriority_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetDepartment(ctx context.Context, in *GroupSetDeptRequest, opts ...grpc.CallOption) (*GroupSetDeptResponse, error) {
	out := new(GroupSetDeptResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetDepartment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetGroup(ctx context.Context, in *GroupSetGroupRequest, opts ...grpc.CallOption) (*GroupSetGroupResponse, error) {
	out := new(GroupSetGroupResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetMaxCores(ctx context.Context, in *GroupSetMaxCoresRequest, opts ...grpc.CallOption) (*GroupSetMaxCoresResponse, error) {
	out := new(GroupSetMaxCoresResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetMaxCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetMinCores(ctx context.Context, in *GroupSetMinCoresRequest, opts ...grpc.CallOption) (*GroupSetMinCoresResponse, error) {
	out := new(GroupSetMinCoresResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetMinCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetMaxGpus(ctx context.Context, in *GroupSetMaxGpusRequest, opts ...grpc.CallOption) (*GroupSetMaxGpusResponse, error) {
	out := new(GroupSetMaxGpusResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetMaxGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetMinGpus(ctx context.Context, in *GroupSetMinGpusRequest, opts ...grpc.CallOption) (*GroupSetMinGpusResponse, error) {
	out := new(GroupSetMinGpusResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetMinGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupInterfaceClient) SetName(ctx context.Context, in *GroupSetNameRequest, opts ...grpc.CallOption) (*GroupSetNameResponse, error) {
	out := new(GroupSetNameResponse)
	err := c.cc.Invoke(ctx, GroupInterface_SetName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupInterfaceServer is the server API for GroupInterface service.
// All implementations must embed UnimplementedGroupInterfaceServer
// for forward compatibility
type GroupInterfaceServer interface {
	// Create a new sub group of the given name
	CreateSubGroup(context.Context, *GroupCreateSubGroupRequest) (*GroupCreateSubGroupResponse, error)
	// Delete the provided group
	Delete(context.Context, *GroupDeleteRequest) (*GroupDeleteResponse, error)
	// Finds a group by show name and group
	FindGroup(context.Context, *GroupFindGroupRequest) (*GroupFindGroupResponse, error)
	// Gets a group by its id
	GetGroup(context.Context, *GroupGetGroupRequest) (*GroupGetGroupResponse, error)
	// Get child groups of the provided group
	GetGroups(context.Context, *GroupGetGroupsRequest) (*GroupGetGroupsResponse, error)
	// Get Jobs of the provided group
	GetJobs(context.Context, *GroupGetJobsRequest) (*GroupGetJobsResponse, error)
	// Reparent the provided groups to the provided group
	ReparentGroups(context.Context, *GroupReparentGroupsRequest) (*GroupReparentGroupsResponse, error)
	// Reparent the provided jobs to the provided group
	ReparentJobs(context.Context, *GroupReparentJobsRequest) (*GroupReparentJobsResponse, error)
	// Set the Default Job Max Core values to all in the provided group
	SetDefaultJobMaxCores(context.Context, *GroupSetDefJobMaxCoresRequest) (*GroupSetDefJobMaxCoresResponse, error)
	// Set the Default Job Min Core values to all in the provided group
	SetDefaultJobMinCores(context.Context, *GroupSetDefJobMinCoresRequest) (*GroupSetDefJobMinCoresResponse, error)
	// Set the Default Job Max Gpu values to all in the provided group
	SetDefaultJobMaxGpus(context.Context, *GroupSetDefJobMaxGpusRequest) (*GroupSetDefJobMaxGpusResponse, error)
	// Set the Default Job Min Gpu values to all in the provided group
	SetDefaultJobMinGpus(context.Context, *GroupSetDefJobMinGpusRequest) (*GroupSetDefJobMinGpusResponse, error)
	// Set the Default Job Priority values to all in the provided group
	SetDefaultJobPriority(context.Context, *GroupSetDefJobPriorityRequest) (*GroupSetDefJobPriorityResponse, error)
	// Set the department associated with the provided group
	SetDepartment(context.Context, *GroupSetDeptRequest) (*GroupSetDeptResponse, error)
	// Set the provided groups parent group
	SetGroup(context.Context, *GroupSetGroupRequest) (*GroupSetGroupResponse, error)
	// Set the group's Max Cores value
	SetMaxCores(context.Context, *GroupSetMaxCoresRequest) (*GroupSetMaxCoresResponse, error)
	// Set the groups Min Cores values
	SetMinCores(context.Context, *GroupSetMinCoresRequest) (*GroupSetMinCoresResponse, error)
	// Set the group's Max Gpu value
	SetMaxGpus(context.Context, *GroupSetMaxGpusRequest) (*GroupSetMaxGpusResponse, error)
	// Set the groups Min Gpu values
	SetMinGpus(context.Context, *GroupSetMinGpusRequest) (*GroupSetMinGpusResponse, error)
	// Set the groups name
	SetName(context.Context, *GroupSetNameRequest) (*GroupSetNameResponse, error)
	mustEmbedUnimplementedGroupInterfaceServer()
}

// UnimplementedGroupInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedGroupInterfaceServer struct {
}

func (UnimplementedGroupInterfaceServer) CreateSubGroup(context.Context, *GroupCreateSubGroupRequest) (*GroupCreateSubGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSubGroup not implemented")
}
func (UnimplementedGroupInterfaceServer) Delete(context.Context, *GroupDeleteRequest) (*GroupDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGroupInterfaceServer) FindGroup(context.Context, *GroupFindGroupRequest) (*GroupFindGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindGroup not implemented")
}
func (UnimplementedGroupInterfaceServer) GetGroup(context.Context, *GroupGetGroupRequest) (*GroupGetGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedGroupInterfaceServer) GetGroups(context.Context, *GroupGetGroupsRequest) (*GroupGetGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroups not implemented")
}
func (UnimplementedGroupInterfaceServer) GetJobs(context.Context, *GroupGetJobsRequest) (*GroupGetJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobs not implemented")
}
func (UnimplementedGroupInterfaceServer) ReparentGroups(context.Context, *GroupReparentGroupsRequest) (*GroupReparentGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReparentGroups not implemented")
}
func (UnimplementedGroupInterfaceServer) ReparentJobs(context.Context, *GroupReparentJobsRequest) (*GroupReparentJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReparentJobs not implemented")
}
func (UnimplementedGroupInterfaceServer) SetDefaultJobMaxCores(context.Context, *GroupSetDefJobMaxCoresRequest) (*GroupSetDefJobMaxCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultJobMaxCores not implemented")
}
func (UnimplementedGroupInterfaceServer) SetDefaultJobMinCores(context.Context, *GroupSetDefJobMinCoresRequest) (*GroupSetDefJobMinCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultJobMinCores not implemented")
}
func (UnimplementedGroupInterfaceServer) SetDefaultJobMaxGpus(context.Context, *GroupSetDefJobMaxGpusRequest) (*GroupSetDefJobMaxGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultJobMaxGpus not implemented")
}
func (UnimplementedGroupInterfaceServer) SetDefaultJobMinGpus(context.Context, *GroupSetDefJobMinGpusRequest) (*GroupSetDefJobMinGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultJobMinGpus not implemented")
}
func (UnimplementedGroupInterfaceServer) SetDefaultJobPriority(context.Context, *GroupSetDefJobPriorityRequest) (*GroupSetDefJobPriorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultJobPriority not implemented")
}
func (UnimplementedGroupInterfaceServer) SetDepartment(context.Context, *GroupSetDeptRequest) (*GroupSetDeptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDepartment not implemented")
}
func (UnimplementedGroupInterfaceServer) SetGroup(context.Context, *GroupSetGroupRequest) (*GroupSetGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGroup not implemented")
}
func (UnimplementedGroupInterfaceServer) SetMaxCores(context.Context, *GroupSetMaxCoresRequest) (*GroupSetMaxCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaxCores not implemented")
}
func (UnimplementedGroupInterfaceServer) SetMinCores(context.Context, *GroupSetMinCoresRequest) (*GroupSetMinCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinCores not implemented")
}
func (UnimplementedGroupInterfaceServer) SetMaxGpus(context.Context, *GroupSetMaxGpusRequest) (*GroupSetMaxGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaxGpus not implemented")
}
func (UnimplementedGroupInterfaceServer) SetMinGpus(context.Context, *GroupSetMinGpusRequest) (*GroupSetMinGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinGpus not implemented")
}
func (UnimplementedGroupInterfaceServer) SetName(context.Context, *GroupSetNameRequest) (*GroupSetNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetName not implemented")
}
func (UnimplementedGroupInterfaceServer) mustEmbedUnimplementedGroupInterfaceServer() {}

// UnsafeGroupInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupInterfaceServer will
// result in compilation errors.
type UnsafeGroupInterfaceServer interface {
	mustEmbedUnimplementedGroupInterfaceServer()
}

func RegisterGroupInterfaceServer(s grpc.ServiceRegistrar, srv GroupInterfaceServer) {
	s.RegisterService(&GroupInterface_ServiceDesc, srv)
}

func _GroupInterface_CreateSubGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupCreateSubGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).CreateSubGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_CreateSubGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).CreateSubGroup(ctx, req.(*GroupCreateSubGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).Delete(ctx, req.(*GroupDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_FindGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupFindGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).FindGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_FindGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).FindGroup(ctx, req.(*GroupFindGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupGetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_GetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).GetGroup(ctx, req.(*GroupGetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_GetGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupGetGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).GetGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_GetGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).GetGroups(ctx, req.(*GroupGetGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_GetJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupGetJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).GetJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_GetJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).GetJobs(ctx, req.(*GroupGetJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_ReparentGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupReparentGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).ReparentGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_ReparentGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).ReparentGroups(ctx, req.(*GroupReparentGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_ReparentJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupReparentJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).ReparentJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_ReparentJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).ReparentJobs(ctx, req.(*GroupReparentJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetDefaultJobMaxCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetDefJobMaxCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetDefaultJobMaxCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetDefaultJobMaxCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetDefaultJobMaxCores(ctx, req.(*GroupSetDefJobMaxCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetDefaultJobMinCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetDefJobMinCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetDefaultJobMinCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetDefaultJobMinCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetDefaultJobMinCores(ctx, req.(*GroupSetDefJobMinCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetDefaultJobMaxGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetDefJobMaxGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetDefaultJobMaxGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetDefaultJobMaxGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetDefaultJobMaxGpus(ctx, req.(*GroupSetDefJobMaxGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetDefaultJobMinGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetDefJobMinGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetDefaultJobMinGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetDefaultJobMinGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetDefaultJobMinGpus(ctx, req.(*GroupSetDefJobMinGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetDefaultJobPriority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetDefJobPriorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetDefaultJobPriority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetDefaultJobPriority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetDefaultJobPriority(ctx, req.(*GroupSetDefJobPriorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetDeptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetDepartment(ctx, req.(*GroupSetDeptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetGroup(ctx, req.(*GroupSetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetMaxCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetMaxCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetMaxCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetMaxCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetMaxCores(ctx, req.(*GroupSetMaxCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetMinCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetMinCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetMinCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetMinCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetMinCores(ctx, req.(*GroupSetMinCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetMaxGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetMaxGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetMaxGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetMaxGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetMaxGpus(ctx, req.(*GroupSetMaxGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetMinGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetMinGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetMinGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetMinGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetMinGpus(ctx, req.(*GroupSetMinGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupInterface_SetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupSetNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupInterfaceServer).SetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupInterface_SetName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupInterfaceServer).SetName(ctx, req.(*GroupSetNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GroupInterface_ServiceDesc is the grpc.ServiceDesc for GroupInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroupInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "job.GroupInterface",
	HandlerType: (*GroupInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSubGroup",
			Handler:    _GroupInterface_CreateSubGroup_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GroupInterface_Delete_Handler,
		},
		{
			MethodName: "FindGroup",
			Handler:    _GroupInterface_FindGroup_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _GroupInterface_GetGroup_Handler,
		},
		{
			MethodName: "GetGroups",
			Handler:    _GroupInterface_GetGroups_Handler,
		},
		{
			MethodName: "GetJobs",
			Handler:    _GroupInterface_GetJobs_Handler,
		},
		{
			MethodName: "ReparentGroups",
			Handler:    _GroupInterface_ReparentGroups_Handler,
		},
		{
			MethodName: "ReparentJobs",
			Handler:    _GroupInterface_ReparentJobs_Handler,
		},
		{
			MethodName: "SetDefaultJobMaxCores",
			Handler:    _GroupInterface_SetDefaultJobMaxCores_Handler,
		},
		{
			MethodName: "SetDefaultJobMinCores",
			Handler:    _GroupInterface_SetDefaultJobMinCores_Handler,
		},
		{
			MethodName: "SetDefaultJobMaxGpus",
			Handler:    _GroupInterface_SetDefaultJobMaxGpus_Handler,
		},
		{
			MethodName: "SetDefaultJobMinGpus",
			Handler:    _GroupInterface_SetDefaultJobMinGpus_Handler,
		},
		{
			MethodName: "SetDefaultJobPriority",
			Handler:    _GroupInterface_SetDefaultJobPriority_Handler,
		},
		{
			MethodName: "SetDepartment",
			Handler:    _GroupInterface_SetDepartment_Handler,
		},
		{
			MethodName: "SetGroup",
			Handler:    _GroupInterface_SetGroup_Handler,
		},
		{
			MethodName: "SetMaxCores",
			Handler:    _GroupInterface_SetMaxCores_Handler,
		},
		{
			MethodName: "SetMinCores",
			Handler:    _GroupInterface_SetMinCores_Handler,
		},
		{
			MethodName: "SetMaxGpus",
			Handler:    _GroupInterface_SetMaxGpus_Handler,
		},
		{
			MethodName: "SetMinGpus",
			Handler:    _GroupInterface_SetMinGpus_Handler,
		},
		{
			MethodName: "SetName",
			Handler:    _GroupInterface_SetName_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/job.proto",
}

const (
	JobInterface_AddComment_FullMethodName              = "/job.JobInterface/AddComment"
	JobInterface_AddRenderPartition_FullMethodName      = "/job.JobInterface/AddRenderPartition"
	JobInterface_CreateDependencyOnFrame_FullMethodName = "/job.JobInterface/CreateDependencyOnFrame"
	JobInterface_CreateDependencyOnJob_FullMethodName   = "/job.JobInterface/CreateDependencyOnJob"
	JobInterface_CreateDependencyOnLayer_FullMethodName = "/job.JobInterface/CreateDependencyOnLayer"
	JobInterface_DropDepends_FullMethodName             = "/job.JobInterface/DropDepends"
	JobInterface_EatFrames_FullMethodName               = "/job.JobInterface/EatFrames"
	JobInterface_FindJob_FullMethodName                 = "/job.JobInterface/FindJob"
	JobInterface_GetComments_FullMethodName             = "/job.JobInterface/GetComments"
	JobInterface_GetCurrent_FullMethodName              = "/job.JobInterface/GetCurrent"
	JobInterface_GetDepends_FullMethodName              = "/job.JobInterface/GetDepends"
	JobInterface_GetFrames_FullMethodName               = "/job.JobInterface/GetFrames"
	JobInterface_GetJob_FullMethodName                  = "/job.JobInterface/GetJob"
	JobInterface_GetJobs_FullMethodName                 = "/job.JobInterface/GetJobs"
	JobInterface_GetJobNames_FullMethodName             = "/job.JobInterface/GetJobNames"
	JobInterface_GetLayers_FullMethodName               = "/job.JobInterface/GetLayers"
	JobInterface_GetUpdatedFrames_FullMethodName        = "/job.JobInterface/GetUpdatedFrames"
	JobInterface_GetWhatDependsOnThis_FullMethodName    = "/job.JobInterface/GetWhatDependsOnThis"
	JobInterface_GetWhatThisDependsOn_FullMethodName    = "/job.JobInterface/GetWhatThisDependsOn"
	JobInterface_IsJobPending_FullMethodName            = "/job.JobInterface/IsJobPending"
	JobInterface_Kill_FullMethodName                    = "/job.JobInterface/Kill"
	JobInterface_KillFrames_FullMethodName              = "/job.JobInterface/KillFrames"
	JobInterface_LaunchSpecAndWait_FullMethodName       = "/job.JobInterface/LaunchSpecAndWait"
	JobInterface_LaunchSpec_FullMethodName              = "/job.JobInterface/LaunchSpec"
	JobInterface_MarkAsWaiting_FullMethodName           = "/job.JobInterface/MarkAsWaiting"
	JobInterface_MarkDoneFrames_FullMethodName          = "/job.JobInterface/MarkDoneFrames"
	JobInterface_Pause_FullMethodName                   = "/job.JobInterface/Pause"
	JobInterface_ReorderFrames_FullMethodName           = "/job.JobInterface/ReorderFrames"
	JobInterface_Resume_FullMethodName                  = "/job.JobInterface/Resume"
	JobInterface_RetryFrames_FullMethodName             = "/job.JobInterface/RetryFrames"
	JobInterface_RunFilters_FullMethodName              = "/job.JobInterface/RunFilters"
	JobInterface_SetAutoEat_FullMethodName              = "/job.JobInterface/SetAutoEat"
	JobInterface_SetGroup_FullMethodName                = "/job.JobInterface/SetGroup"
	JobInterface_SetMaxCores_FullMethodName             = "/job.JobInterface/SetMaxCores"
	JobInterface_SetMaxRetries_FullMethodName           = "/job.JobInterface/SetMaxRetries"
	JobInterface_SetMinCores_FullMethodName             = "/job.JobInterface/SetMinCores"
	JobInterface_SetMaxGpus_FullMethodName              = "/job.JobInterface/SetMaxGpus"
	JobInterface_SetMinGpus_FullMethodName              = "/job.JobInterface/SetMinGpus"
	JobInterface_SetPriority_FullMethodName             = "/job.JobInterface/SetPriority"
	JobInterface_ShutdownIfCompleted_FullMethodName     = "/job.JobInterface/ShutdownIfCompleted"
	JobInterface_StaggerFrames_FullMethodName           = "/job.JobInterface/StaggerFrames"
)

// JobInterfaceClient is the client API for JobInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobInterfaceClient interface {
	// Add a comment on this job
	AddComment(ctx context.Context, in *JobAddCommentRequest, opts ...grpc.CallOption) (*JobAddCommentResponse, error)
	// Add a render partition to the local host.  This partition will
	// run frames on the specified job.
	AddRenderPartition(ctx context.Context, in *JobAddRenderPartRequest, opts ...grpc.CallOption) (*JobAddRenderPartResponse, error)
	// Setup and retunrn a JobOnFrame dependency
	CreateDependencyOnFrame(ctx context.Context, in *JobCreateDependencyOnFrameRequest, opts ...grpc.CallOption) (*JobCreateDependencyOnFrameResponse, error)
	// Setup and return a JobOnJob dependency
	CreateDependencyOnJob(ctx context.Context, in *JobCreateDependencyOnJobRequest, opts ...grpc.CallOption) (*JobCreateDependencyOnJobResponse, error)
	// Setup and retunrn a JobOnLayer dependency
	CreateDependencyOnLayer(ctx context.Context, in *JobCreateDependencyOnLayerRequest, opts ...grpc.CallOption) (*JobCreateDependencyOnLayerResponse, error)
	// Drops all external dependencies for the job.  This means that
	// the internal depend structure will be maintained, but everything
	// that depends on another job will be dropped.
	DropDepends(ctx context.Context, in *JobDropDependsRequest, opts ...grpc.CallOption) (*JobDropDependsResponse, error)
	// Eats all frames that match the FrameSearchCriteria
	EatFrames(ctx context.Context, in *JobEatFramesRequest, opts ...grpc.CallOption) (*JobEatFramesResponse, error)
	// Finds a pending job using the job name
	FindJob(ctx context.Context, in *JobFindJobRequest, opts ...grpc.CallOption) (*JobFindJobResponse, error)
	// Get the comments for this job
	GetComments(ctx context.Context, in *JobGetCommentsRequest, opts ...grpc.CallOption) (*JobGetCommentsResponse, error)
	// Get the job details
	GetCurrent(ctx context.Context, in *JobGetCurrentRequest, opts ...grpc.CallOption) (*JobGetCurrentResponse, error)
	// Returns a list of all dependencies that this job is involved with
	GetDepends(ctx context.Context, in *JobGetDependsRequest, opts ...grpc.CallOption) (*JobGetDependsResponse, error)
	// Returns all frame objects that match FrameSearchCriteria
	GetFrames(ctx context.Context, in *JobGetFramesRequest, opts ...grpc.CallOption) (*JobGetFramesResponse, error)
	// Finds a pending job using the job name
	GetJob(ctx context.Context, in *JobGetJobRequest, opts ...grpc.CallOption) (*JobGetJobResponse, error)
	// Returns a list of jobs based on specified criteria
	GetJobs(ctx context.Context, in *JobGetJobsRequest, opts ...grpc.CallOption) (*JobGetJobsResponse, error)
	// Returns a sequence of job names using search criteria
	GetJobNames(ctx context.Context, in *JobGetJobNamesRequest, opts ...grpc.CallOption) (*JobGetJobNamesResponse, error)
	// Returns all layer objects
	GetLayers(ctx context.Context, in *JobGetLayersRequest, opts ...grpc.CallOption) (*JobGetLayersResponse, error)
	// Returns a UpdatedFrameCheckResult which contains
	// updated state information for frames that have changed since the
	// last update time as well as the current state of the job.
	//
	// If the user is filtering by layer, passing an array of layer
	// proxies will limit the updates to specific layers.
	//
	// At most, your going to get 1 update per running frame every minute
	// due to memory usage.
	GetUpdatedFrames(ctx context.Context, in *JobGetUpdatedFramesRequest, opts ...grpc.CallOption) (*JobGetUpdatedFramesResponse, error)
	// Returns a list of dependencies setup to depend on
	// this job.  This includes all types of depends, not just
	// OnJob dependencies.  This will not return any frame on frame
	// dependencies that are part of a FrameByFrame depend.  It will
	// return a single element that represents the entire dependency.
	GetWhatDependsOnThis(ctx context.Context, in *JobGetWhatDependsOnThisRequest, opts ...grpc.CallOption) (*JobGetWhatDependsOnThisResponse, error)
	// Returns a list of dependencies that this frame depends on.
	GetWhatThisDependsOn(ctx context.Context, in *JobGetWhatThisDependsOnRequest, opts ...grpc.CallOption) (*JobGetWhatThisDependsOnResponse, error)
	// Returns true if the job is in the pending state the cue.
	IsJobPending(ctx context.Context, in *JobIsJobPendingRequest, opts ...grpc.CallOption) (*JobIsJobPendingResponse, error)
	// Kill the job.  This puts the job into the Finished State
	//
	//	All running frames are killed, all depends satisfied.
	Kill(ctx context.Context, in *JobKillRequest, opts ...grpc.CallOption) (*JobKillResponse, error)
	// Kills all frames that match the FrameSearchCriteria
	KillFrames(ctx context.Context, in *JobKillFramesRequest, opts ...grpc.CallOption) (*JobKillFramesResponse, error)
	// Launches a job spec and returns an array of launched jobs. Waits for jobs to be committed to DB.  This might time
	// out before jobs are launched.
	LaunchSpecAndWait(ctx context.Context, in *JobLaunchSpecAndWaitRequest, opts ...grpc.CallOption) (*JobLaunchSpecAndWaitResponse, error)
	// Launches as a job spec and returns an array of job names that are being launched. This method returns immediately
	// after basic checks. The job could fail to launch of a DB error occurs but that is rare.
	LaunchSpec(ctx context.Context, in *JobLaunchSpecRequest, opts ...grpc.CallOption) (*JobLaunchSpecResponse, error)
	// Updates the matching frames from the Depend state to the waiting state
	MarkAsWaiting(ctx context.Context, in *JobMarkAsWaitingRequest, opts ...grpc.CallOption) (*JobMarkAsWaitingResponse, error)
	// Drops any dependency that requires any frame that matches the FrameSearchCriteria
	MarkDoneFrames(ctx context.Context, in *JobMarkDoneFramesRequest, opts ...grpc.CallOption) (*JobMarkDoneFramesResponse, error)
	// Pauses the job, which means it no longer gets procs
	Pause(ctx context.Context, in *JobPauseRequest, opts ...grpc.CallOption) (*JobPauseResponse, error)
	// Reorders the specified frame range on this job
	ReorderFrames(ctx context.Context, in *JobReorderFramesRequest, opts ...grpc.CallOption) (*JobReorderFramesResponse, error)
	// Resumes a paused job
	Resume(ctx context.Context, in *JobResumeRequest, opts ...grpc.CallOption) (*JobResumeResponse, error)
	// Retries all frames that match the FrameSearchCriteria
	RetryFrames(ctx context.Context, in *JobRetryFramesRequest, opts ...grpc.CallOption) (*JobRetryFramesResponse, error)
	// Rerun filters for this job
	RunFilters(ctx context.Context, in *JobRunFiltersRequest, opts ...grpc.CallOption) (*JobRunFiltersResponse, error)
	// If set to true, a frame that would have turned dead, will become eaten
	SetAutoEat(ctx context.Context, in *JobSetAutoEatRequest, opts ...grpc.CallOption) (*JobSetAutoEatResponse, error)
	// Move the job into the specified group
	SetGroup(ctx context.Context, in *JobSetGroupRequest, opts ...grpc.CallOption) (*JobSetGroupResponse, error)
	// Sets the maximum number of procs that can run on this job
	SetMaxCores(ctx context.Context, in *JobSetMaxCoresRequest, opts ...grpc.CallOption) (*JobSetMaxCoresResponse, error)
	// Sets the default maximum number of frame retries for the job. One
	// a frame has retried this many times it will automatically go
	// to the dead state. The default upper limit on this is 16 retries.
	SetMaxRetries(ctx context.Context, in *JobSetMaxRetriesRequest, opts ...grpc.CallOption) (*JobSetMaxRetriesResponse, error)
	// Sets the minimum number of procs that can run on this job
	SetMinCores(ctx context.Context, in *JobSetMinCoresRequest, opts ...grpc.CallOption) (*JobSetMinCoresResponse, error)
	// Sets the maximum number of Gpu that can run on this job
	SetMaxGpus(ctx context.Context, in *JobSetMaxGpusRequest, opts ...grpc.CallOption) (*JobSetMaxGpusResponse, error)
	// Sets the minimum number of Gpu that can run on this job
	SetMinGpus(ctx context.Context, in *JobSetMinGpusRequest, opts ...grpc.CallOption) (*JobSetMinGpusResponse, error)
	// Sets the job priority
	SetPriority(ctx context.Context, in *JobSetPriorityRequest, opts ...grpc.CallOption) (*JobSetPriorityResponse, error)
	// Shutdown the job if it is completed. This is a workaround for when
	// Cuebot failed to shutdown a job due to database access error.
	ShutdownIfCompleted(ctx context.Context, in *JobShutdownIfCompletedRequest, opts ...grpc.CallOption) (*JobShutdownIfCompletedResponse, error)
	// Staggers the specified frame range
	StaggerFrames(ctx context.Context, in *JobStaggerFramesRequest, opts ...grpc.CallOption) (*JobStaggerFramesResponse, error)
}

type jobInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobInterfaceClient(cc grpc.ClientConnInterface) JobInterfaceClient {
	return &jobInterfaceClient{cc}
}

func (c *jobInterfaceClient) AddComment(ctx context.Context, in *JobAddCommentRequest, opts ...grpc.CallOption) (*JobAddCommentResponse, error) {
	out := new(JobAddCommentResponse)
	err := c.cc.Invoke(ctx, JobInterface_AddComment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) AddRenderPartition(ctx context.Context, in *JobAddRenderPartRequest, opts ...grpc.CallOption) (*JobAddRenderPartResponse, error) {
	out := new(JobAddRenderPartResponse)
	err := c.cc.Invoke(ctx, JobInterface_AddRenderPartition_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) CreateDependencyOnFrame(ctx context.Context, in *JobCreateDependencyOnFrameRequest, opts ...grpc.CallOption) (*JobCreateDependencyOnFrameResponse, error) {
	out := new(JobCreateDependencyOnFrameResponse)
	err := c.cc.Invoke(ctx, JobInterface_CreateDependencyOnFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) CreateDependencyOnJob(ctx context.Context, in *JobCreateDependencyOnJobRequest, opts ...grpc.CallOption) (*JobCreateDependencyOnJobResponse, error) {
	out := new(JobCreateDependencyOnJobResponse)
	err := c.cc.Invoke(ctx, JobInterface_CreateDependencyOnJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) CreateDependencyOnLayer(ctx context.Context, in *JobCreateDependencyOnLayerRequest, opts ...grpc.CallOption) (*JobCreateDependencyOnLayerResponse, error) {
	out := new(JobCreateDependencyOnLayerResponse)
	err := c.cc.Invoke(ctx, JobInterface_CreateDependencyOnLayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) DropDepends(ctx context.Context, in *JobDropDependsRequest, opts ...grpc.CallOption) (*JobDropDependsResponse, error) {
	out := new(JobDropDependsResponse)
	err := c.cc.Invoke(ctx, JobInterface_DropDepends_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) EatFrames(ctx context.Context, in *JobEatFramesRequest, opts ...grpc.CallOption) (*JobEatFramesResponse, error) {
	out := new(JobEatFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_EatFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) FindJob(ctx context.Context, in *JobFindJobRequest, opts ...grpc.CallOption) (*JobFindJobResponse, error) {
	out := new(JobFindJobResponse)
	err := c.cc.Invoke(ctx, JobInterface_FindJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetComments(ctx context.Context, in *JobGetCommentsRequest, opts ...grpc.CallOption) (*JobGetCommentsResponse, error) {
	out := new(JobGetCommentsResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetComments_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetCurrent(ctx context.Context, in *JobGetCurrentRequest, opts ...grpc.CallOption) (*JobGetCurrentResponse, error) {
	out := new(JobGetCurrentResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetCurrent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetDepends(ctx context.Context, in *JobGetDependsRequest, opts ...grpc.CallOption) (*JobGetDependsResponse, error) {
	out := new(JobGetDependsResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetDepends_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetFrames(ctx context.Context, in *JobGetFramesRequest, opts ...grpc.CallOption) (*JobGetFramesResponse, error) {
	out := new(JobGetFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetJob(ctx context.Context, in *JobGetJobRequest, opts ...grpc.CallOption) (*JobGetJobResponse, error) {
	out := new(JobGetJobResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetJobs(ctx context.Context, in *JobGetJobsRequest, opts ...grpc.CallOption) (*JobGetJobsResponse, error) {
	out := new(JobGetJobsResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetJobs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetJobNames(ctx context.Context, in *JobGetJobNamesRequest, opts ...grpc.CallOption) (*JobGetJobNamesResponse, error) {
	out := new(JobGetJobNamesResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetJobNames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetLayers(ctx context.Context, in *JobGetLayersRequest, opts ...grpc.CallOption) (*JobGetLayersResponse, error) {
	out := new(JobGetLayersResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetLayers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetUpdatedFrames(ctx context.Context, in *JobGetUpdatedFramesRequest, opts ...grpc.CallOption) (*JobGetUpdatedFramesResponse, error) {
	out := new(JobGetUpdatedFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetUpdatedFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetWhatDependsOnThis(ctx context.Context, in *JobGetWhatDependsOnThisRequest, opts ...grpc.CallOption) (*JobGetWhatDependsOnThisResponse, error) {
	out := new(JobGetWhatDependsOnThisResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetWhatDependsOnThis_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) GetWhatThisDependsOn(ctx context.Context, in *JobGetWhatThisDependsOnRequest, opts ...grpc.CallOption) (*JobGetWhatThisDependsOnResponse, error) {
	out := new(JobGetWhatThisDependsOnResponse)
	err := c.cc.Invoke(ctx, JobInterface_GetWhatThisDependsOn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) IsJobPending(ctx context.Context, in *JobIsJobPendingRequest, opts ...grpc.CallOption) (*JobIsJobPendingResponse, error) {
	out := new(JobIsJobPendingResponse)
	err := c.cc.Invoke(ctx, JobInterface_IsJobPending_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) Kill(ctx context.Context, in *JobKillRequest, opts ...grpc.CallOption) (*JobKillResponse, error) {
	out := new(JobKillResponse)
	err := c.cc.Invoke(ctx, JobInterface_Kill_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) KillFrames(ctx context.Context, in *JobKillFramesRequest, opts ...grpc.CallOption) (*JobKillFramesResponse, error) {
	out := new(JobKillFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_KillFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) LaunchSpecAndWait(ctx context.Context, in *JobLaunchSpecAndWaitRequest, opts ...grpc.CallOption) (*JobLaunchSpecAndWaitResponse, error) {
	out := new(JobLaunchSpecAndWaitResponse)
	err := c.cc.Invoke(ctx, JobInterface_LaunchSpecAndWait_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) LaunchSpec(ctx context.Context, in *JobLaunchSpecRequest, opts ...grpc.CallOption) (*JobLaunchSpecResponse, error) {
	out := new(JobLaunchSpecResponse)
	err := c.cc.Invoke(ctx, JobInterface_LaunchSpec_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) MarkAsWaiting(ctx context.Context, in *JobMarkAsWaitingRequest, opts ...grpc.CallOption) (*JobMarkAsWaitingResponse, error) {
	out := new(JobMarkAsWaitingResponse)
	err := c.cc.Invoke(ctx, JobInterface_MarkAsWaiting_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) MarkDoneFrames(ctx context.Context, in *JobMarkDoneFramesRequest, opts ...grpc.CallOption) (*JobMarkDoneFramesResponse, error) {
	out := new(JobMarkDoneFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_MarkDoneFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) Pause(ctx context.Context, in *JobPauseRequest, opts ...grpc.CallOption) (*JobPauseResponse, error) {
	out := new(JobPauseResponse)
	err := c.cc.Invoke(ctx, JobInterface_Pause_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) ReorderFrames(ctx context.Context, in *JobReorderFramesRequest, opts ...grpc.CallOption) (*JobReorderFramesResponse, error) {
	out := new(JobReorderFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_ReorderFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) Resume(ctx context.Context, in *JobResumeRequest, opts ...grpc.CallOption) (*JobResumeResponse, error) {
	out := new(JobResumeResponse)
	err := c.cc.Invoke(ctx, JobInterface_Resume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) RetryFrames(ctx context.Context, in *JobRetryFramesRequest, opts ...grpc.CallOption) (*JobRetryFramesResponse, error) {
	out := new(JobRetryFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_RetryFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) RunFilters(ctx context.Context, in *JobRunFiltersRequest, opts ...grpc.CallOption) (*JobRunFiltersResponse, error) {
	out := new(JobRunFiltersResponse)
	err := c.cc.Invoke(ctx, JobInterface_RunFilters_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetAutoEat(ctx context.Context, in *JobSetAutoEatRequest, opts ...grpc.CallOption) (*JobSetAutoEatResponse, error) {
	out := new(JobSetAutoEatResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetAutoEat_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetGroup(ctx context.Context, in *JobSetGroupRequest, opts ...grpc.CallOption) (*JobSetGroupResponse, error) {
	out := new(JobSetGroupResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetMaxCores(ctx context.Context, in *JobSetMaxCoresRequest, opts ...grpc.CallOption) (*JobSetMaxCoresResponse, error) {
	out := new(JobSetMaxCoresResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetMaxCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetMaxRetries(ctx context.Context, in *JobSetMaxRetriesRequest, opts ...grpc.CallOption) (*JobSetMaxRetriesResponse, error) {
	out := new(JobSetMaxRetriesResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetMaxRetries_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetMinCores(ctx context.Context, in *JobSetMinCoresRequest, opts ...grpc.CallOption) (*JobSetMinCoresResponse, error) {
	out := new(JobSetMinCoresResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetMinCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetMaxGpus(ctx context.Context, in *JobSetMaxGpusRequest, opts ...grpc.CallOption) (*JobSetMaxGpusResponse, error) {
	out := new(JobSetMaxGpusResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetMaxGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetMinGpus(ctx context.Context, in *JobSetMinGpusRequest, opts ...grpc.CallOption) (*JobSetMinGpusResponse, error) {
	out := new(JobSetMinGpusResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetMinGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) SetPriority(ctx context.Context, in *JobSetPriorityRequest, opts ...grpc.CallOption) (*JobSetPriorityResponse, error) {
	out := new(JobSetPriorityResponse)
	err := c.cc.Invoke(ctx, JobInterface_SetPriority_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) ShutdownIfCompleted(ctx context.Context, in *JobShutdownIfCompletedRequest, opts ...grpc.CallOption) (*JobShutdownIfCompletedResponse, error) {
	out := new(JobShutdownIfCompletedResponse)
	err := c.cc.Invoke(ctx, JobInterface_ShutdownIfCompleted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobInterfaceClient) StaggerFrames(ctx context.Context, in *JobStaggerFramesRequest, opts ...grpc.CallOption) (*JobStaggerFramesResponse, error) {
	out := new(JobStaggerFramesResponse)
	err := c.cc.Invoke(ctx, JobInterface_StaggerFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobInterfaceServer is the server API for JobInterface service.
// All implementations must embed UnimplementedJobInterfaceServer
// for forward compatibility
type JobInterfaceServer interface {
	// Add a comment on this job
	AddComment(context.Context, *JobAddCommentRequest) (*JobAddCommentResponse, error)
	// Add a render partition to the local host.  This partition will
	// run frames on the specified job.
	AddRenderPartition(context.Context, *JobAddRenderPartRequest) (*JobAddRenderPartResponse, error)
	// Setup and retunrn a JobOnFrame dependency
	CreateDependencyOnFrame(context.Context, *JobCreateDependencyOnFrameRequest) (*JobCreateDependencyOnFrameResponse, error)
	// Setup and return a JobOnJob dependency
	CreateDependencyOnJob(context.Context, *JobCreateDependencyOnJobRequest) (*JobCreateDependencyOnJobResponse, error)
	// Setup and retunrn a JobOnLayer dependency
	CreateDependencyOnLayer(context.Context, *JobCreateDependencyOnLayerRequest) (*JobCreateDependencyOnLayerResponse, error)
	// Drops all external dependencies for the job.  This means that
	// the internal depend structure will be maintained, but everything
	// that depends on another job will be dropped.
	DropDepends(context.Context, *JobDropDependsRequest) (*JobDropDependsResponse, error)
	// Eats all frames that match the FrameSearchCriteria
	EatFrames(context.Context, *JobEatFramesRequest) (*JobEatFramesResponse, error)
	// Finds a pending job using the job name
	FindJob(context.Context, *JobFindJobRequest) (*JobFindJobResponse, error)
	// Get the comments for this job
	GetComments(context.Context, *JobGetCommentsRequest) (*JobGetCommentsResponse, error)
	// Get the job details
	GetCurrent(context.Context, *JobGetCurrentRequest) (*JobGetCurrentResponse, error)
	// Returns a list of all dependencies that this job is involved with
	GetDepends(context.Context, *JobGetDependsRequest) (*JobGetDependsResponse, error)
	// Returns all frame objects that match FrameSearchCriteria
	GetFrames(context.Context, *JobGetFramesRequest) (*JobGetFramesResponse, error)
	// Finds a pending job using the job name
	GetJob(context.Context, *JobGetJobRequest) (*JobGetJobResponse, error)
	// Returns a list of jobs based on specified criteria
	GetJobs(context.Context, *JobGetJobsRequest) (*JobGetJobsResponse, error)
	// Returns a sequence of job names using search criteria
	GetJobNames(context.Context, *JobGetJobNamesRequest) (*JobGetJobNamesResponse, error)
	// Returns all layer objects
	GetLayers(context.Context, *JobGetLayersRequest) (*JobGetLayersResponse, error)
	// Returns a UpdatedFrameCheckResult which contains
	// updated state information for frames that have changed since the
	// last update time as well as the current state of the job.
	//
	// If the user is filtering by layer, passing an array of layer
	// proxies will limit the updates to specific layers.
	//
	// At most, your going to get 1 update per running frame every minute
	// due to memory usage.
	GetUpdatedFrames(context.Context, *JobGetUpdatedFramesRequest) (*JobGetUpdatedFramesResponse, error)
	// Returns a list of dependencies setup to depend on
	// this job.  This includes all types of depends, not just
	// OnJob dependencies.  This will not return any frame on frame
	// dependencies that are part of a FrameByFrame depend.  It will
	// return a single element that represents the entire dependency.
	GetWhatDependsOnThis(context.Context, *JobGetWhatDependsOnThisRequest) (*JobGetWhatDependsOnThisResponse, error)
	// Returns a list of dependencies that this frame depends on.
	GetWhatThisDependsOn(context.Context, *JobGetWhatThisDependsOnRequest) (*JobGetWhatThisDependsOnResponse, error)
	// Returns true if the job is in the pending state the cue.
	IsJobPending(context.Context, *JobIsJobPendingRequest) (*JobIsJobPendingResponse, error)
	// Kill the job.  This puts the job into the Finished State
	//
	//	All running frames are killed, all depends satisfied.
	Kill(context.Context, *JobKillRequest) (*JobKillResponse, error)
	// Kills all frames that match the FrameSearchCriteria
	KillFrames(context.Context, *JobKillFramesRequest) (*JobKillFramesResponse, error)
	// Launches a job spec and returns an array of launched jobs. Waits for jobs to be committed to DB.  This might time
	// out before jobs are launched.
	LaunchSpecAndWait(context.Context, *JobLaunchSpecAndWaitRequest) (*JobLaunchSpecAndWaitResponse, error)
	// Launches as a job spec and returns an array of job names that are being launched. This method returns immediately
	// after basic checks. The job could fail to launch of a DB error occurs but that is rare.
	LaunchSpec(context.Context, *JobLaunchSpecRequest) (*JobLaunchSpecResponse, error)
	// Updates the matching frames from the Depend state to the waiting state
	MarkAsWaiting(context.Context, *JobMarkAsWaitingRequest) (*JobMarkAsWaitingResponse, error)
	// Drops any dependency that requires any frame that matches the FrameSearchCriteria
	MarkDoneFrames(context.Context, *JobMarkDoneFramesRequest) (*JobMarkDoneFramesResponse, error)
	// Pauses the job, which means it no longer gets procs
	Pause(context.Context, *JobPauseRequest) (*JobPauseResponse, error)
	// Reorders the specified frame range on this job
	ReorderFrames(context.Context, *JobReorderFramesRequest) (*JobReorderFramesResponse, error)
	// Resumes a paused job
	Resume(context.Context, *JobResumeRequest) (*JobResumeResponse, error)
	// Retries all frames that match the FrameSearchCriteria
	RetryFrames(context.Context, *JobRetryFramesRequest) (*JobRetryFramesResponse, error)
	// Rerun filters for this job
	RunFilters(context.Context, *JobRunFiltersRequest) (*JobRunFiltersResponse, error)
	// If set to true, a frame that would have turned dead, will become eaten
	SetAutoEat(context.Context, *JobSetAutoEatRequest) (*JobSetAutoEatResponse, error)
	// Move the job into the specified group
	SetGroup(context.Context, *JobSetGroupRequest) (*JobSetGroupResponse, error)
	// Sets the maximum number of procs that can run on this job
	SetMaxCores(context.Context, *JobSetMaxCoresRequest) (*JobSetMaxCoresResponse, error)
	// Sets the default maximum number of frame retries for the job. One
	// a frame has retried this many times it will automatically go
	// to the dead state. The default upper limit on this is 16 retries.
	SetMaxRetries(context.Context, *JobSetMaxRetriesRequest) (*JobSetMaxRetriesResponse, error)
	// Sets the minimum number of procs that can run on this job
	SetMinCores(context.Context, *JobSetMinCoresRequest) (*JobSetMinCoresResponse, error)
	// Sets the maximum number of Gpu that can run on this job
	SetMaxGpus(context.Context, *JobSetMaxGpusRequest) (*JobSetMaxGpusResponse, error)
	// Sets the minimum number of Gpu that can run on this job
	SetMinGpus(context.Context, *JobSetMinGpusRequest) (*JobSetMinGpusResponse, error)
	// Sets the job priority
	SetPriority(context.Context, *JobSetPriorityRequest) (*JobSetPriorityResponse, error)
	// Shutdown the job if it is completed. This is a workaround for when
	// Cuebot failed to shutdown a job due to database access error.
	ShutdownIfCompleted(context.Context, *JobShutdownIfCompletedRequest) (*JobShutdownIfCompletedResponse, error)
	// Staggers the specified frame range
	StaggerFrames(context.Context, *JobStaggerFramesRequest) (*JobStaggerFramesResponse, error)
	mustEmbedUnimplementedJobInterfaceServer()
}

// UnimplementedJobInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedJobInterfaceServer struct {
}

func (UnimplementedJobInterfaceServer) AddComment(context.Context, *JobAddCommentRequest) (*JobAddCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddComment not implemented")
}
func (UnimplementedJobInterfaceServer) AddRenderPartition(context.Context, *JobAddRenderPartRequest) (*JobAddRenderPartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRenderPartition not implemented")
}
func (UnimplementedJobInterfaceServer) CreateDependencyOnFrame(context.Context, *JobCreateDependencyOnFrameRequest) (*JobCreateDependencyOnFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnFrame not implemented")
}
func (UnimplementedJobInterfaceServer) CreateDependencyOnJob(context.Context, *JobCreateDependencyOnJobRequest) (*JobCreateDependencyOnJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnJob not implemented")
}
func (UnimplementedJobInterfaceServer) CreateDependencyOnLayer(context.Context, *JobCreateDependencyOnLayerRequest) (*JobCreateDependencyOnLayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnLayer not implemented")
}
func (UnimplementedJobInterfaceServer) DropDepends(context.Context, *JobDropDependsRequest) (*JobDropDependsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropDepends not implemented")
}
func (UnimplementedJobInterfaceServer) EatFrames(context.Context, *JobEatFramesRequest) (*JobEatFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EatFrames not implemented")
}
func (UnimplementedJobInterfaceServer) FindJob(context.Context, *JobFindJobRequest) (*JobFindJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindJob not implemented")
}
func (UnimplementedJobInterfaceServer) GetComments(context.Context, *JobGetCommentsRequest) (*JobGetCommentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComments not implemented")
}
func (UnimplementedJobInterfaceServer) GetCurrent(context.Context, *JobGetCurrentRequest) (*JobGetCurrentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrent not implemented")
}
func (UnimplementedJobInterfaceServer) GetDepends(context.Context, *JobGetDependsRequest) (*JobGetDependsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDepends not implemented")
}
func (UnimplementedJobInterfaceServer) GetFrames(context.Context, *JobGetFramesRequest) (*JobGetFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFrames not implemented")
}
func (UnimplementedJobInterfaceServer) GetJob(context.Context, *JobGetJobRequest) (*JobGetJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedJobInterfaceServer) GetJobs(context.Context, *JobGetJobsRequest) (*JobGetJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobs not implemented")
}
func (UnimplementedJobInterfaceServer) GetJobNames(context.Context, *JobGetJobNamesRequest) (*JobGetJobNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobNames not implemented")
}
func (UnimplementedJobInterfaceServer) GetLayers(context.Context, *JobGetLayersRequest) (*JobGetLayersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLayers not implemented")
}
func (UnimplementedJobInterfaceServer) GetUpdatedFrames(context.Context, *JobGetUpdatedFramesRequest) (*JobGetUpdatedFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUpdatedFrames not implemented")
}
func (UnimplementedJobInterfaceServer) GetWhatDependsOnThis(context.Context, *JobGetWhatDependsOnThisRequest) (*JobGetWhatDependsOnThisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWhatDependsOnThis not implemented")
}
func (UnimplementedJobInterfaceServer) GetWhatThisDependsOn(context.Context, *JobGetWhatThisDependsOnRequest) (*JobGetWhatThisDependsOnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWhatThisDependsOn not implemented")
}
func (UnimplementedJobInterfaceServer) IsJobPending(context.Context, *JobIsJobPendingRequest) (*JobIsJobPendingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsJobPending not implemented")
}
func (UnimplementedJobInterfaceServer) Kill(context.Context, *JobKillRequest) (*JobKillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kill not implemented")
}
func (UnimplementedJobInterfaceServer) KillFrames(context.Context, *JobKillFramesRequest) (*JobKillFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillFrames not implemented")
}
func (UnimplementedJobInterfaceServer) LaunchSpecAndWait(context.Context, *JobLaunchSpecAndWaitRequest) (*JobLaunchSpecAndWaitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LaunchSpecAndWait not implemented")
}
func (UnimplementedJobInterfaceServer) LaunchSpec(context.Context, *JobLaunchSpecRequest) (*JobLaunchSpecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LaunchSpec not implemented")
}
func (UnimplementedJobInterfaceServer) MarkAsWaiting(context.Context, *JobMarkAsWaitingRequest) (*JobMarkAsWaitingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAsWaiting not implemented")
}
func (UnimplementedJobInterfaceServer) MarkDoneFrames(context.Context, *JobMarkDoneFramesRequest) (*JobMarkDoneFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkDoneFrames not implemented")
}
func (UnimplementedJobInterfaceServer) Pause(context.Context, *JobPauseRequest) (*JobPauseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (UnimplementedJobInterfaceServer) ReorderFrames(context.Context, *JobReorderFramesRequest) (*JobReorderFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReorderFrames not implemented")
}
func (UnimplementedJobInterfaceServer) Resume(context.Context, *JobResumeRequest) (*JobResumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resume not implemented")
}
func (UnimplementedJobInterfaceServer) RetryFrames(context.Context, *JobRetryFramesRequest) (*JobRetryFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetryFrames not implemented")
}
func (UnimplementedJobInterfaceServer) RunFilters(context.Context, *JobRunFiltersRequest) (*JobRunFiltersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunFilters not implemented")
}
func (UnimplementedJobInterfaceServer) SetAutoEat(context.Context, *JobSetAutoEatRequest) (*JobSetAutoEatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAutoEat not implemented")
}
func (UnimplementedJobInterfaceServer) SetGroup(context.Context, *JobSetGroupRequest) (*JobSetGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGroup not implemented")
}
func (UnimplementedJobInterfaceServer) SetMaxCores(context.Context, *JobSetMaxCoresRequest) (*JobSetMaxCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaxCores not implemented")
}
func (UnimplementedJobInterfaceServer) SetMaxRetries(context.Context, *JobSetMaxRetriesRequest) (*JobSetMaxRetriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaxRetries not implemented")
}
func (UnimplementedJobInterfaceServer) SetMinCores(context.Context, *JobSetMinCoresRequest) (*JobSetMinCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinCores not implemented")
}
func (UnimplementedJobInterfaceServer) SetMaxGpus(context.Context, *JobSetMaxGpusRequest) (*JobSetMaxGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaxGpus not implemented")
}
func (UnimplementedJobInterfaceServer) SetMinGpus(context.Context, *JobSetMinGpusRequest) (*JobSetMinGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinGpus not implemented")
}
func (UnimplementedJobInterfaceServer) SetPriority(context.Context, *JobSetPriorityRequest) (*JobSetPriorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPriority not implemented")
}
func (UnimplementedJobInterfaceServer) ShutdownIfCompleted(context.Context, *JobShutdownIfCompletedRequest) (*JobShutdownIfCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutdownIfCompleted not implemented")
}
func (UnimplementedJobInterfaceServer) StaggerFrames(context.Context, *JobStaggerFramesRequest) (*JobStaggerFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StaggerFrames not implemented")
}
func (UnimplementedJobInterfaceServer) mustEmbedUnimplementedJobInterfaceServer() {}

// UnsafeJobInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobInterfaceServer will
// result in compilation errors.
type UnsafeJobInterfaceServer interface {
	mustEmbedUnimplementedJobInterfaceServer()
}

func RegisterJobInterfaceServer(s grpc.ServiceRegistrar, srv JobInterfaceServer) {
	s.RegisterService(&JobInterface_ServiceDesc, srv)
}

func _JobInterface_AddComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobAddCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).AddComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_AddComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).AddComment(ctx, req.(*JobAddCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_AddRenderPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobAddRenderPartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).AddRenderPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_AddRenderPartition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).AddRenderPartition(ctx, req.(*JobAddRenderPartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_CreateDependencyOnFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobCreateDependencyOnFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).CreateDependencyOnFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_CreateDependencyOnFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).CreateDependencyOnFrame(ctx, req.(*JobCreateDependencyOnFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_CreateDependencyOnJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobCreateDependencyOnJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).CreateDependencyOnJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_CreateDependencyOnJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).CreateDependencyOnJob(ctx, req.(*JobCreateDependencyOnJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_CreateDependencyOnLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobCreateDependencyOnLayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).CreateDependencyOnLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_CreateDependencyOnLayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).CreateDependencyOnLayer(ctx, req.(*JobCreateDependencyOnLayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_DropDepends_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobDropDependsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).DropDepends(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_DropDepends_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).DropDepends(ctx, req.(*JobDropDependsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_EatFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobEatFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).EatFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_EatFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).EatFrames(ctx, req.(*JobEatFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_FindJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobFindJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).FindJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_FindJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).FindJob(ctx, req.(*JobFindJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetComments(ctx, req.(*JobGetCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetCurrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetCurrentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetCurrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetCurrent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetCurrent(ctx, req.(*JobGetCurrentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetDepends_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetDependsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetDepends(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetDepends_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetDepends(ctx, req.(*JobGetDependsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetFrames(ctx, req.(*JobGetFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetJob(ctx, req.(*JobGetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetJobs(ctx, req.(*JobGetJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetJobNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetJobNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetJobNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetJobNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetJobNames(ctx, req.(*JobGetJobNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetLayers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetLayersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetLayers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetLayers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetLayers(ctx, req.(*JobGetLayersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetUpdatedFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetUpdatedFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetUpdatedFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetUpdatedFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetUpdatedFrames(ctx, req.(*JobGetUpdatedFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetWhatDependsOnThis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetWhatDependsOnThisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetWhatDependsOnThis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetWhatDependsOnThis_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetWhatDependsOnThis(ctx, req.(*JobGetWhatDependsOnThisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_GetWhatThisDependsOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobGetWhatThisDependsOnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).GetWhatThisDependsOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_GetWhatThisDependsOn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).GetWhatThisDependsOn(ctx, req.(*JobGetWhatThisDependsOnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_IsJobPending_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobIsJobPendingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).IsJobPending(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_IsJobPending_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).IsJobPending(ctx, req.(*JobIsJobPendingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_Kill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobKillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).Kill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_Kill_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).Kill(ctx, req.(*JobKillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_KillFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobKillFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).KillFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_KillFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).KillFrames(ctx, req.(*JobKillFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_LaunchSpecAndWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobLaunchSpecAndWaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).LaunchSpecAndWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_LaunchSpecAndWait_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).LaunchSpecAndWait(ctx, req.(*JobLaunchSpecAndWaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_LaunchSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobLaunchSpecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).LaunchSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_LaunchSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).LaunchSpec(ctx, req.(*JobLaunchSpecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_MarkAsWaiting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobMarkAsWaitingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).MarkAsWaiting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_MarkAsWaiting_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).MarkAsWaiting(ctx, req.(*JobMarkAsWaitingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_MarkDoneFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobMarkDoneFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).MarkDoneFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_MarkDoneFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).MarkDoneFrames(ctx, req.(*JobMarkDoneFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobPauseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_Pause_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).Pause(ctx, req.(*JobPauseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_ReorderFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobReorderFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).ReorderFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_ReorderFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).ReorderFrames(ctx, req.(*JobReorderFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_Resume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobResumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).Resume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_Resume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).Resume(ctx, req.(*JobResumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_RetryFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRetryFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).RetryFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_RetryFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).RetryFrames(ctx, req.(*JobRetryFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_RunFilters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRunFiltersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).RunFilters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_RunFilters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).RunFilters(ctx, req.(*JobRunFiltersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetAutoEat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetAutoEatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetAutoEat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetAutoEat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetAutoEat(ctx, req.(*JobSetAutoEatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetGroup(ctx, req.(*JobSetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetMaxCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetMaxCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetMaxCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetMaxCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetMaxCores(ctx, req.(*JobSetMaxCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetMaxRetries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetMaxRetriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetMaxRetries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetMaxRetries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetMaxRetries(ctx, req.(*JobSetMaxRetriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetMinCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetMinCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetMinCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetMinCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetMinCores(ctx, req.(*JobSetMinCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetMaxGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetMaxGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetMaxGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetMaxGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetMaxGpus(ctx, req.(*JobSetMaxGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetMinGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetMinGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetMinGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetMinGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetMinGpus(ctx, req.(*JobSetMinGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_SetPriority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetPriorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).SetPriority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_SetPriority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).SetPriority(ctx, req.(*JobSetPriorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_ShutdownIfCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobShutdownIfCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).ShutdownIfCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_ShutdownIfCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).ShutdownIfCompleted(ctx, req.(*JobShutdownIfCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobInterface_StaggerFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobStaggerFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobInterfaceServer).StaggerFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobInterface_StaggerFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobInterfaceServer).StaggerFrames(ctx, req.(*JobStaggerFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JobInterface_ServiceDesc is the grpc.ServiceDesc for JobInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "job.JobInterface",
	HandlerType: (*JobInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddComment",
			Handler:    _JobInterface_AddComment_Handler,
		},
		{
			MethodName: "AddRenderPartition",
			Handler:    _JobInterface_AddRenderPartition_Handler,
		},
		{
			MethodName: "CreateDependencyOnFrame",
			Handler:    _JobInterface_CreateDependencyOnFrame_Handler,
		},
		{
			MethodName: "CreateDependencyOnJob",
			Handler:    _JobInterface_CreateDependencyOnJob_Handler,
		},
		{
			MethodName: "CreateDependencyOnLayer",
			Handler:    _JobInterface_CreateDependencyOnLayer_Handler,
		},
		{
			MethodName: "DropDepends",
			Handler:    _JobInterface_DropDepends_Handler,
		},
		{
			MethodName: "EatFrames",
			Handler:    _JobInterface_EatFrames_Handler,
		},
		{
			MethodName: "FindJob",
			Handler:    _JobInterface_FindJob_Handler,
		},
		{
			MethodName: "GetComments",
			Handler:    _JobInterface_GetComments_Handler,
		},
		{
			MethodName: "GetCurrent",
			Handler:    _JobInterface_GetCurrent_Handler,
		},
		{
			MethodName: "GetDepends",
			Handler:    _JobInterface_GetDepends_Handler,
		},
		{
			MethodName: "GetFrames",
			Handler:    _JobInterface_GetFrames_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _JobInterface_GetJob_Handler,
		},
		{
			MethodName: "GetJobs",
			Handler:    _JobInterface_GetJobs_Handler,
		},
		{
			MethodName: "GetJobNames",
			Handler:    _JobInterface_GetJobNames_Handler,
		},
		{
			MethodName: "GetLayers",
			Handler:    _JobInterface_GetLayers_Handler,
		},
		{
			MethodName: "GetUpdatedFrames",
			Handler:    _JobInterface_GetUpdatedFrames_Handler,
		},
		{
			MethodName: "GetWhatDependsOnThis",
			Handler:    _JobInterface_GetWhatDependsOnThis_Handler,
		},
		{
			MethodName: "GetWhatThisDependsOn",
			Handler:    _JobInterface_GetWhatThisDependsOn_Handler,
		},
		{
			MethodName: "IsJobPending",
			Handler:    _JobInterface_IsJobPending_Handler,
		},
		{
			MethodName: "Kill",
			Handler:    _JobInterface_Kill_Handler,
		},
		{
			MethodName: "KillFrames",
			Handler:    _JobInterface_KillFrames_Handler,
		},
		{
			MethodName: "LaunchSpecAndWait",
			Handler:    _JobInterface_LaunchSpecAndWait_Handler,
		},
		{
			MethodName: "LaunchSpec",
			Handler:    _JobInterface_LaunchSpec_Handler,
		},
		{
			MethodName: "MarkAsWaiting",
			Handler:    _JobInterface_MarkAsWaiting_Handler,
		},
		{
			MethodName: "MarkDoneFrames",
			Handler:    _JobInterface_MarkDoneFrames_Handler,
		},
		{
			MethodName: "Pause",
			Handler:    _JobInterface_Pause_Handler,
		},
		{
			MethodName: "ReorderFrames",
			Handler:    _JobInterface_ReorderFrames_Handler,
		},
		{
			MethodName: "Resume",
			Handler:    _JobInterface_Resume_Handler,
		},
		{
			MethodName: "RetryFrames",
			Handler:    _JobInterface_RetryFrames_Handler,
		},
		{
			MethodName: "RunFilters",
			Handler:    _JobInterface_RunFilters_Handler,
		},
		{
			MethodName: "SetAutoEat",
			Handler:    _JobInterface_SetAutoEat_Handler,
		},
		{
			MethodName: "SetGroup",
			Handler:    _JobInterface_SetGroup_Handler,
		},
		{
			MethodName: "SetMaxCores",
			Handler:    _JobInterface_SetMaxCores_Handler,
		},
		{
			MethodName: "SetMaxRetries",
			Handler:    _JobInterface_SetMaxRetries_Handler,
		},
		{
			MethodName: "SetMinCores",
			Handler:    _JobInterface_SetMinCores_Handler,
		},
		{
			MethodName: "SetMaxGpus",
			Handler:    _JobInterface_SetMaxGpus_Handler,
		},
		{
			MethodName: "SetMinGpus",
			Handler:    _JobInterface_SetMinGpus_Handler,
		},
		{
			MethodName: "SetPriority",
			Handler:    _JobInterface_SetPriority_Handler,
		},
		{
			MethodName: "ShutdownIfCompleted",
			Handler:    _JobInterface_ShutdownIfCompleted_Handler,
		},
		{
			MethodName: "StaggerFrames",
			Handler:    _JobInterface_StaggerFrames_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/job.proto",
}

const (
	LayerInterface_AddLimit_FullMethodName                     = "/job.LayerInterface/AddLimit"
	LayerInterface_AddRenderPartition_FullMethodName           = "/job.LayerInterface/AddRenderPartition"
	LayerInterface_CreateDependencyOnFrame_FullMethodName      = "/job.LayerInterface/CreateDependencyOnFrame"
	LayerInterface_CreateDependencyOnJob_FullMethodName        = "/job.LayerInterface/CreateDependencyOnJob"
	LayerInterface_CreateDependencyOnLayer_FullMethodName      = "/job.LayerInterface/CreateDependencyOnLayer"
	LayerInterface_CreateFrameByFrameDependency_FullMethodName = "/job.LayerInterface/CreateFrameByFrameDependency"
	LayerInterface_DropDepends_FullMethodName                  = "/job.LayerInterface/DropDepends"
	LayerInterface_DropLimit_FullMethodName                    = "/job.LayerInterface/DropLimit"
	LayerInterface_EatFrames_FullMethodName                    = "/job.LayerInterface/EatFrames"
	LayerInterface_EnableMemoryOptimizer_FullMethodName        = "/job.LayerInterface/EnableMemoryOptimizer"
	LayerInterface_FindLayer_FullMethodName                    = "/job.LayerInterface/FindLayer"
	LayerInterface_GetFrames_FullMethodName                    = "/job.LayerInterface/GetFrames"
	LayerInterface_GetLayer_FullMethodName                     = "/job.LayerInterface/GetLayer"
	LayerInterface_GetLimits_FullMethodName                    = "/job.LayerInterface/GetLimits"
	LayerInterface_GetOutputPaths_FullMethodName               = "/job.LayerInterface/GetOutputPaths"
	LayerInterface_GetWhatThisDependsOn_FullMethodName         = "/job.LayerInterface/GetWhatThisDependsOn"
	LayerInterface_GetWhatDependsOnThis_FullMethodName         = "/job.LayerInterface/GetWhatDependsOnThis"
	LayerInterface_KillFrames_FullMethodName                   = "/job.LayerInterface/KillFrames"
	LayerInterface_MarkdoneFrames_FullMethodName               = "/job.LayerInterface/MarkdoneFrames"
	LayerInterface_RegisterOutputPath_FullMethodName           = "/job.LayerInterface/RegisterOutputPath"
	LayerInterface_ReorderFrames_FullMethodName                = "/job.LayerInterface/ReorderFrames"
	LayerInterface_RetryFrames_FullMethodName                  = "/job.LayerInterface/RetryFrames"
	LayerInterface_SetMaxCores_FullMethodName                  = "/job.LayerInterface/SetMaxCores"
	LayerInterface_SetMinCores_FullMethodName                  = "/job.LayerInterface/SetMinCores"
	LayerInterface_SetMaxGpus_FullMethodName                   = "/job.LayerInterface/SetMaxGpus"
	LayerInterface_SetMinGpus_FullMethodName                   = "/job.LayerInterface/SetMinGpus"
	LayerInterface_SetMinGpuMemory_FullMethodName              = "/job.LayerInterface/SetMinGpuMemory"
	LayerInterface_SetMinGpu_FullMethodName                    = "/job.LayerInterface/SetMinGpu"
	LayerInterface_SetMinMemory_FullMethodName                 = "/job.LayerInterface/SetMinMemory"
	LayerInterface_SetTags_FullMethodName                      = "/job.LayerInterface/SetTags"
	LayerInterface_SetThreadable_FullMethodName                = "/job.LayerInterface/SetThreadable"
	LayerInterface_SetTimeout_FullMethodName                   = "/job.LayerInterface/SetTimeout"
	LayerInterface_SetTimeoutLLU_FullMethodName                = "/job.LayerInterface/SetTimeoutLLU"
	LayerInterface_StaggerFrames_FullMethodName                = "/job.LayerInterface/StaggerFrames"
)

// LayerInterfaceClient is the client API for LayerInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LayerInterfaceClient interface {
	// Add Limit to the Layer
	AddLimit(ctx context.Context, in *LayerAddLimitRequest, opts ...grpc.CallOption) (*LayerAddLimitResponse, error)
	// Add RenderPartition to Layer
	AddRenderPartition(ctx context.Context, in *LayerAddRenderPartitionRequest, opts ...grpc.CallOption) (*LayerAddRenderPartitionResponse, error)
	// Setup and return a LayerOnFrame dependency
	CreateDependencyOnFrame(ctx context.Context, in *LayerCreateDependOnFrameRequest, opts ...grpc.CallOption) (*LayerCreateDependOnFrameResponse, error)
	// Setup and return a LayerOnJob dependency
	CreateDependencyOnJob(ctx context.Context, in *LayerCreateDependOnJobRequest, opts ...grpc.CallOption) (*LayerCreateDependOnJobResponse, error)
	// Setup and return a LayerOnLayer dependency
	CreateDependencyOnLayer(ctx context.Context, in *LayerCreateDependOnLayerRequest, opts ...grpc.CallOption) (*LayerCreateDependOnLayerResponse, error)
	// Setup and return a FrameByFrame dependency
	CreateFrameByFrameDependency(ctx context.Context, in *LayerCreateFrameByFrameDependRequest, opts ...grpc.CallOption) (*LayerCreateFrameByFrameDependResponse, error)
	// Drops every dependency that is causing this layer not to run.
	DropDepends(ctx context.Context, in *LayerDropDependsRequest, opts ...grpc.CallOption) (*LayerDropDependsResponse, error)
	// Drop the limit from the specified layer.
	DropLimit(ctx context.Context, in *LayerDropLimitRequest, opts ...grpc.CallOption) (*LayerDropLimitResponse, error)
	// Eat the Frames of this Layer
	EatFrames(ctx context.Context, in *LayerEatFramesRequest, opts ...grpc.CallOption) (*LayerEatFramesResponse, error)
	// When disabled, This will stop Cuebot from lowering the amount of memory required for a given layer.
	EnableMemoryOptimizer(ctx context.Context, in *LayerEnableMemoryOptimizerRequest, opts ...grpc.CallOption) (*LayerEnableMemoryOptimizerResponse, error)
	// Finds a layer in a pending job based the job and layer name
	FindLayer(ctx context.Context, in *LayerFindLayerRequest, opts ...grpc.CallOption) (*LayerFindLayerResponse, error)
	// Get the frames that match the FrameSearchCriteria
	GetFrames(ctx context.Context, in *LayerGetFramesRequest, opts ...grpc.CallOption) (*LayerGetFramesResponse, error)
	// Finds a layer in a pending job from its unique ID
	GetLayer(ctx context.Context, in *LayerGetLayerRequest, opts ...grpc.CallOption) (*LayerGetLayerResponse, error)
	// Return a list of the limits on the specified layer.
	GetLimits(ctx context.Context, in *LayerGetLimitsRequest, opts ...grpc.CallOption) (*LayerGetLimitsResponse, error)
	// Return a list of all registered output paths.
	GetOutputPaths(ctx context.Context, in *LayerGetOutputPathsRequest, opts ...grpc.CallOption) (*LayerGetOutputPathsResponse, error)
	// Returns a list of dependencies that this frame depends on.
	GetWhatThisDependsOn(ctx context.Context, in *LayerGetWhatThisDependsOnRequest, opts ...grpc.CallOption) (*LayerGetWhatThisDependsOnResponse, error)
	// Returns a list of dependencies setup to depend on this layer.  This includes all types of depends, not just
	// OnLayer dependencies.  This will not return any frame on frame dependencies that are part of a FrameByFrame
	// depend.  It will return a single element that represents the entire dependency.
	GetWhatDependsOnThis(ctx context.Context, in *LayerGetWhatDependsOnThisRequest, opts ...grpc.CallOption) (*LayerGetWhatDependsOnThisResponse, error)
	// Kill Frames associated with this layer
	KillFrames(ctx context.Context, in *LayerKillFramesRequest, opts ...grpc.CallOption) (*LayerKillFramesResponse, error)
	// Mark the frames of this layer done
	MarkdoneFrames(ctx context.Context, in *LayerMarkdoneFramesRequest, opts ...grpc.CallOption) (*LayerMarkdoneFramesResponse, error)
	// Register an output with the given layer.  The output paths are sent in the opencue email.
	RegisterOutputPath(ctx context.Context, in *LayerRegisterOutputPathRequest, opts ...grpc.CallOption) (*LayerRegisterOutputPathResponse, error)
	// Reorders the specified frame range on this job.
	ReorderFrames(ctx context.Context, in *LayerReorderFramesRequest, opts ...grpc.CallOption) (*LayerReorderFramesResponse, error)
	// Retry the Frames of this Layer
	RetryFrames(ctx context.Context, in *LayerRetryFramesRequest, opts ...grpc.CallOption) (*LayerRetryFramesResponse, error)
	// The maximum number of cores to run on a given frame within this layer.  Fractional core values are not allowed
	// with this setting.
	SetMaxCores(ctx context.Context, in *LayerSetMaxCoresRequest, opts ...grpc.CallOption) (*LayerSetMaxCoresResponse, error)
	// Set the Min Cores for this layer
	SetMinCores(ctx context.Context, in *LayerSetMinCoresRequest, opts ...grpc.CallOption) (*LayerSetMinCoresResponse, error)
	// The maximum number of Gpu to run on a given frame within this layer.
	SetMaxGpus(ctx context.Context, in *LayerSetMaxGpusRequest, opts ...grpc.CallOption) (*LayerSetMaxGpusResponse, error)
	// Set the Min Gpus for this layer
	SetMinGpus(ctx context.Context, in *LayerSetMinGpusRequest, opts ...grpc.CallOption) (*LayerSetMinGpusResponse, error)
	// Set the Min gpu memory value for the layer
	SetMinGpuMemory(ctx context.Context, in *LayerSetMinGpuMemoryRequest, opts ...grpc.CallOption) (*LayerSetMinGpuMemoryResponse, error)
	// [Deprecated] Set the Min gpu memory value for the layer
	SetMinGpu(ctx context.Context, in *LayerSetMinGpuRequest, opts ...grpc.CallOption) (*LayerSetMinGpuResponse, error)
	// Set the Min Memory value for the layer
	SetMinMemory(ctx context.Context, in *LayerSetMinMemoryRequest, opts ...grpc.CallOption) (*LayerSetMinMemoryResponse, error)
	// Set tags on the layer
	SetTags(ctx context.Context, in *LayerSetTagsRequest, opts ...grpc.CallOption) (*LayerSetTagsResponse, error)
	// Set whether the layer is threadable or not
	SetThreadable(ctx context.Context, in *LayerSetThreadableRequest, opts ...grpc.CallOption) (*LayerSetThreadableResponse, error)
	// Set whether the timeout for frames in the layer
	SetTimeout(ctx context.Context, in *LayerSetTimeoutRequest, opts ...grpc.CallOption) (*LayerSetTimeoutResponse, error)
	// Set whether the LLU timeout for frames in the layer
	SetTimeoutLLU(ctx context.Context, in *LayerSetTimeoutLLURequest, opts ...grpc.CallOption) (*LayerSetTimeoutLLUResponse, error)
	// Staggers the specified frame range.
	StaggerFrames(ctx context.Context, in *LayerStaggerFramesRequest, opts ...grpc.CallOption) (*LayerStaggerFramesResponse, error)
}

type layerInterfaceClient struct {
	cc grpc.ClientConnInterface
}

func NewLayerInterfaceClient(cc grpc.ClientConnInterface) LayerInterfaceClient {
	return &layerInterfaceClient{cc}
}

func (c *layerInterfaceClient) AddLimit(ctx context.Context, in *LayerAddLimitRequest, opts ...grpc.CallOption) (*LayerAddLimitResponse, error) {
	out := new(LayerAddLimitResponse)
	err := c.cc.Invoke(ctx, LayerInterface_AddLimit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) AddRenderPartition(ctx context.Context, in *LayerAddRenderPartitionRequest, opts ...grpc.CallOption) (*LayerAddRenderPartitionResponse, error) {
	out := new(LayerAddRenderPartitionResponse)
	err := c.cc.Invoke(ctx, LayerInterface_AddRenderPartition_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) CreateDependencyOnFrame(ctx context.Context, in *LayerCreateDependOnFrameRequest, opts ...grpc.CallOption) (*LayerCreateDependOnFrameResponse, error) {
	out := new(LayerCreateDependOnFrameResponse)
	err := c.cc.Invoke(ctx, LayerInterface_CreateDependencyOnFrame_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) CreateDependencyOnJob(ctx context.Context, in *LayerCreateDependOnJobRequest, opts ...grpc.CallOption) (*LayerCreateDependOnJobResponse, error) {
	out := new(LayerCreateDependOnJobResponse)
	err := c.cc.Invoke(ctx, LayerInterface_CreateDependencyOnJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) CreateDependencyOnLayer(ctx context.Context, in *LayerCreateDependOnLayerRequest, opts ...grpc.CallOption) (*LayerCreateDependOnLayerResponse, error) {
	out := new(LayerCreateDependOnLayerResponse)
	err := c.cc.Invoke(ctx, LayerInterface_CreateDependencyOnLayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) CreateFrameByFrameDependency(ctx context.Context, in *LayerCreateFrameByFrameDependRequest, opts ...grpc.CallOption) (*LayerCreateFrameByFrameDependResponse, error) {
	out := new(LayerCreateFrameByFrameDependResponse)
	err := c.cc.Invoke(ctx, LayerInterface_CreateFrameByFrameDependency_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) DropDepends(ctx context.Context, in *LayerDropDependsRequest, opts ...grpc.CallOption) (*LayerDropDependsResponse, error) {
	out := new(LayerDropDependsResponse)
	err := c.cc.Invoke(ctx, LayerInterface_DropDepends_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) DropLimit(ctx context.Context, in *LayerDropLimitRequest, opts ...grpc.CallOption) (*LayerDropLimitResponse, error) {
	out := new(LayerDropLimitResponse)
	err := c.cc.Invoke(ctx, LayerInterface_DropLimit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) EatFrames(ctx context.Context, in *LayerEatFramesRequest, opts ...grpc.CallOption) (*LayerEatFramesResponse, error) {
	out := new(LayerEatFramesResponse)
	err := c.cc.Invoke(ctx, LayerInterface_EatFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) EnableMemoryOptimizer(ctx context.Context, in *LayerEnableMemoryOptimizerRequest, opts ...grpc.CallOption) (*LayerEnableMemoryOptimizerResponse, error) {
	out := new(LayerEnableMemoryOptimizerResponse)
	err := c.cc.Invoke(ctx, LayerInterface_EnableMemoryOptimizer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) FindLayer(ctx context.Context, in *LayerFindLayerRequest, opts ...grpc.CallOption) (*LayerFindLayerResponse, error) {
	out := new(LayerFindLayerResponse)
	err := c.cc.Invoke(ctx, LayerInterface_FindLayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) GetFrames(ctx context.Context, in *LayerGetFramesRequest, opts ...grpc.CallOption) (*LayerGetFramesResponse, error) {
	out := new(LayerGetFramesResponse)
	err := c.cc.Invoke(ctx, LayerInterface_GetFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) GetLayer(ctx context.Context, in *LayerGetLayerRequest, opts ...grpc.CallOption) (*LayerGetLayerResponse, error) {
	out := new(LayerGetLayerResponse)
	err := c.cc.Invoke(ctx, LayerInterface_GetLayer_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) GetLimits(ctx context.Context, in *LayerGetLimitsRequest, opts ...grpc.CallOption) (*LayerGetLimitsResponse, error) {
	out := new(LayerGetLimitsResponse)
	err := c.cc.Invoke(ctx, LayerInterface_GetLimits_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) GetOutputPaths(ctx context.Context, in *LayerGetOutputPathsRequest, opts ...grpc.CallOption) (*LayerGetOutputPathsResponse, error) {
	out := new(LayerGetOutputPathsResponse)
	err := c.cc.Invoke(ctx, LayerInterface_GetOutputPaths_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) GetWhatThisDependsOn(ctx context.Context, in *LayerGetWhatThisDependsOnRequest, opts ...grpc.CallOption) (*LayerGetWhatThisDependsOnResponse, error) {
	out := new(LayerGetWhatThisDependsOnResponse)
	err := c.cc.Invoke(ctx, LayerInterface_GetWhatThisDependsOn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) GetWhatDependsOnThis(ctx context.Context, in *LayerGetWhatDependsOnThisRequest, opts ...grpc.CallOption) (*LayerGetWhatDependsOnThisResponse, error) {
	out := new(LayerGetWhatDependsOnThisResponse)
	err := c.cc.Invoke(ctx, LayerInterface_GetWhatDependsOnThis_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) KillFrames(ctx context.Context, in *LayerKillFramesRequest, opts ...grpc.CallOption) (*LayerKillFramesResponse, error) {
	out := new(LayerKillFramesResponse)
	err := c.cc.Invoke(ctx, LayerInterface_KillFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) MarkdoneFrames(ctx context.Context, in *LayerMarkdoneFramesRequest, opts ...grpc.CallOption) (*LayerMarkdoneFramesResponse, error) {
	out := new(LayerMarkdoneFramesResponse)
	err := c.cc.Invoke(ctx, LayerInterface_MarkdoneFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) RegisterOutputPath(ctx context.Context, in *LayerRegisterOutputPathRequest, opts ...grpc.CallOption) (*LayerRegisterOutputPathResponse, error) {
	out := new(LayerRegisterOutputPathResponse)
	err := c.cc.Invoke(ctx, LayerInterface_RegisterOutputPath_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) ReorderFrames(ctx context.Context, in *LayerReorderFramesRequest, opts ...grpc.CallOption) (*LayerReorderFramesResponse, error) {
	out := new(LayerReorderFramesResponse)
	err := c.cc.Invoke(ctx, LayerInterface_ReorderFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) RetryFrames(ctx context.Context, in *LayerRetryFramesRequest, opts ...grpc.CallOption) (*LayerRetryFramesResponse, error) {
	out := new(LayerRetryFramesResponse)
	err := c.cc.Invoke(ctx, LayerInterface_RetryFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetMaxCores(ctx context.Context, in *LayerSetMaxCoresRequest, opts ...grpc.CallOption) (*LayerSetMaxCoresResponse, error) {
	out := new(LayerSetMaxCoresResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetMaxCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetMinCores(ctx context.Context, in *LayerSetMinCoresRequest, opts ...grpc.CallOption) (*LayerSetMinCoresResponse, error) {
	out := new(LayerSetMinCoresResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetMinCores_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetMaxGpus(ctx context.Context, in *LayerSetMaxGpusRequest, opts ...grpc.CallOption) (*LayerSetMaxGpusResponse, error) {
	out := new(LayerSetMaxGpusResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetMaxGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetMinGpus(ctx context.Context, in *LayerSetMinGpusRequest, opts ...grpc.CallOption) (*LayerSetMinGpusResponse, error) {
	out := new(LayerSetMinGpusResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetMinGpus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetMinGpuMemory(ctx context.Context, in *LayerSetMinGpuMemoryRequest, opts ...grpc.CallOption) (*LayerSetMinGpuMemoryResponse, error) {
	out := new(LayerSetMinGpuMemoryResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetMinGpuMemory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetMinGpu(ctx context.Context, in *LayerSetMinGpuRequest, opts ...grpc.CallOption) (*LayerSetMinGpuResponse, error) {
	out := new(LayerSetMinGpuResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetMinGpu_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetMinMemory(ctx context.Context, in *LayerSetMinMemoryRequest, opts ...grpc.CallOption) (*LayerSetMinMemoryResponse, error) {
	out := new(LayerSetMinMemoryResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetMinMemory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetTags(ctx context.Context, in *LayerSetTagsRequest, opts ...grpc.CallOption) (*LayerSetTagsResponse, error) {
	out := new(LayerSetTagsResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetThreadable(ctx context.Context, in *LayerSetThreadableRequest, opts ...grpc.CallOption) (*LayerSetThreadableResponse, error) {
	out := new(LayerSetThreadableResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetThreadable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetTimeout(ctx context.Context, in *LayerSetTimeoutRequest, opts ...grpc.CallOption) (*LayerSetTimeoutResponse, error) {
	out := new(LayerSetTimeoutResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetTimeout_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) SetTimeoutLLU(ctx context.Context, in *LayerSetTimeoutLLURequest, opts ...grpc.CallOption) (*LayerSetTimeoutLLUResponse, error) {
	out := new(LayerSetTimeoutLLUResponse)
	err := c.cc.Invoke(ctx, LayerInterface_SetTimeoutLLU_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layerInterfaceClient) StaggerFrames(ctx context.Context, in *LayerStaggerFramesRequest, opts ...grpc.CallOption) (*LayerStaggerFramesResponse, error) {
	out := new(LayerStaggerFramesResponse)
	err := c.cc.Invoke(ctx, LayerInterface_StaggerFrames_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LayerInterfaceServer is the server API for LayerInterface service.
// All implementations must embed UnimplementedLayerInterfaceServer
// for forward compatibility
type LayerInterfaceServer interface {
	// Add Limit to the Layer
	AddLimit(context.Context, *LayerAddLimitRequest) (*LayerAddLimitResponse, error)
	// Add RenderPartition to Layer
	AddRenderPartition(context.Context, *LayerAddRenderPartitionRequest) (*LayerAddRenderPartitionResponse, error)
	// Setup and return a LayerOnFrame dependency
	CreateDependencyOnFrame(context.Context, *LayerCreateDependOnFrameRequest) (*LayerCreateDependOnFrameResponse, error)
	// Setup and return a LayerOnJob dependency
	CreateDependencyOnJob(context.Context, *LayerCreateDependOnJobRequest) (*LayerCreateDependOnJobResponse, error)
	// Setup and return a LayerOnLayer dependency
	CreateDependencyOnLayer(context.Context, *LayerCreateDependOnLayerRequest) (*LayerCreateDependOnLayerResponse, error)
	// Setup and return a FrameByFrame dependency
	CreateFrameByFrameDependency(context.Context, *LayerCreateFrameByFrameDependRequest) (*LayerCreateFrameByFrameDependResponse, error)
	// Drops every dependency that is causing this layer not to run.
	DropDepends(context.Context, *LayerDropDependsRequest) (*LayerDropDependsResponse, error)
	// Drop the limit from the specified layer.
	DropLimit(context.Context, *LayerDropLimitRequest) (*LayerDropLimitResponse, error)
	// Eat the Frames of this Layer
	EatFrames(context.Context, *LayerEatFramesRequest) (*LayerEatFramesResponse, error)
	// When disabled, This will stop Cuebot from lowering the amount of memory required for a given layer.
	EnableMemoryOptimizer(context.Context, *LayerEnableMemoryOptimizerRequest) (*LayerEnableMemoryOptimizerResponse, error)
	// Finds a layer in a pending job based the job and layer name
	FindLayer(context.Context, *LayerFindLayerRequest) (*LayerFindLayerResponse, error)
	// Get the frames that match the FrameSearchCriteria
	GetFrames(context.Context, *LayerGetFramesRequest) (*LayerGetFramesResponse, error)
	// Finds a layer in a pending job from its unique ID
	GetLayer(context.Context, *LayerGetLayerRequest) (*LayerGetLayerResponse, error)
	// Return a list of the limits on the specified layer.
	GetLimits(context.Context, *LayerGetLimitsRequest) (*LayerGetLimitsResponse, error)
	// Return a list of all registered output paths.
	GetOutputPaths(context.Context, *LayerGetOutputPathsRequest) (*LayerGetOutputPathsResponse, error)
	// Returns a list of dependencies that this frame depends on.
	GetWhatThisDependsOn(context.Context, *LayerGetWhatThisDependsOnRequest) (*LayerGetWhatThisDependsOnResponse, error)
	// Returns a list of dependencies setup to depend on this layer.  This includes all types of depends, not just
	// OnLayer dependencies.  This will not return any frame on frame dependencies that are part of a FrameByFrame
	// depend.  It will return a single element that represents the entire dependency.
	GetWhatDependsOnThis(context.Context, *LayerGetWhatDependsOnThisRequest) (*LayerGetWhatDependsOnThisResponse, error)
	// Kill Frames associated with this layer
	KillFrames(context.Context, *LayerKillFramesRequest) (*LayerKillFramesResponse, error)
	// Mark the frames of this layer done
	MarkdoneFrames(context.Context, *LayerMarkdoneFramesRequest) (*LayerMarkdoneFramesResponse, error)
	// Register an output with the given layer.  The output paths are sent in the opencue email.
	RegisterOutputPath(context.Context, *LayerRegisterOutputPathRequest) (*LayerRegisterOutputPathResponse, error)
	// Reorders the specified frame range on this job.
	ReorderFrames(context.Context, *LayerReorderFramesRequest) (*LayerReorderFramesResponse, error)
	// Retry the Frames of this Layer
	RetryFrames(context.Context, *LayerRetryFramesRequest) (*LayerRetryFramesResponse, error)
	// The maximum number of cores to run on a given frame within this layer.  Fractional core values are not allowed
	// with this setting.
	SetMaxCores(context.Context, *LayerSetMaxCoresRequest) (*LayerSetMaxCoresResponse, error)
	// Set the Min Cores for this layer
	SetMinCores(context.Context, *LayerSetMinCoresRequest) (*LayerSetMinCoresResponse, error)
	// The maximum number of Gpu to run on a given frame within this layer.
	SetMaxGpus(context.Context, *LayerSetMaxGpusRequest) (*LayerSetMaxGpusResponse, error)
	// Set the Min Gpus for this layer
	SetMinGpus(context.Context, *LayerSetMinGpusRequest) (*LayerSetMinGpusResponse, error)
	// Set the Min gpu memory value for the layer
	SetMinGpuMemory(context.Context, *LayerSetMinGpuMemoryRequest) (*LayerSetMinGpuMemoryResponse, error)
	// [Deprecated] Set the Min gpu memory value for the layer
	SetMinGpu(context.Context, *LayerSetMinGpuRequest) (*LayerSetMinGpuResponse, error)
	// Set the Min Memory value for the layer
	SetMinMemory(context.Context, *LayerSetMinMemoryRequest) (*LayerSetMinMemoryResponse, error)
	// Set tags on the layer
	SetTags(context.Context, *LayerSetTagsRequest) (*LayerSetTagsResponse, error)
	// Set whether the layer is threadable or not
	SetThreadable(context.Context, *LayerSetThreadableRequest) (*LayerSetThreadableResponse, error)
	// Set whether the timeout for frames in the layer
	SetTimeout(context.Context, *LayerSetTimeoutRequest) (*LayerSetTimeoutResponse, error)
	// Set whether the LLU timeout for frames in the layer
	SetTimeoutLLU(context.Context, *LayerSetTimeoutLLURequest) (*LayerSetTimeoutLLUResponse, error)
	// Staggers the specified frame range.
	StaggerFrames(context.Context, *LayerStaggerFramesRequest) (*LayerStaggerFramesResponse, error)
	mustEmbedUnimplementedLayerInterfaceServer()
}

// UnimplementedLayerInterfaceServer must be embedded to have forward compatible implementations.
type UnimplementedLayerInterfaceServer struct {
}

func (UnimplementedLayerInterfaceServer) AddLimit(context.Context, *LayerAddLimitRequest) (*LayerAddLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLimit not implemented")
}
func (UnimplementedLayerInterfaceServer) AddRenderPartition(context.Context, *LayerAddRenderPartitionRequest) (*LayerAddRenderPartitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRenderPartition not implemented")
}
func (UnimplementedLayerInterfaceServer) CreateDependencyOnFrame(context.Context, *LayerCreateDependOnFrameRequest) (*LayerCreateDependOnFrameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnFrame not implemented")
}
func (UnimplementedLayerInterfaceServer) CreateDependencyOnJob(context.Context, *LayerCreateDependOnJobRequest) (*LayerCreateDependOnJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnJob not implemented")
}
func (UnimplementedLayerInterfaceServer) CreateDependencyOnLayer(context.Context, *LayerCreateDependOnLayerRequest) (*LayerCreateDependOnLayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDependencyOnLayer not implemented")
}
func (UnimplementedLayerInterfaceServer) CreateFrameByFrameDependency(context.Context, *LayerCreateFrameByFrameDependRequest) (*LayerCreateFrameByFrameDependResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFrameByFrameDependency not implemented")
}
func (UnimplementedLayerInterfaceServer) DropDepends(context.Context, *LayerDropDependsRequest) (*LayerDropDependsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropDepends not implemented")
}
func (UnimplementedLayerInterfaceServer) DropLimit(context.Context, *LayerDropLimitRequest) (*LayerDropLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropLimit not implemented")
}
func (UnimplementedLayerInterfaceServer) EatFrames(context.Context, *LayerEatFramesRequest) (*LayerEatFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EatFrames not implemented")
}
func (UnimplementedLayerInterfaceServer) EnableMemoryOptimizer(context.Context, *LayerEnableMemoryOptimizerRequest) (*LayerEnableMemoryOptimizerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableMemoryOptimizer not implemented")
}
func (UnimplementedLayerInterfaceServer) FindLayer(context.Context, *LayerFindLayerRequest) (*LayerFindLayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindLayer not implemented")
}
func (UnimplementedLayerInterfaceServer) GetFrames(context.Context, *LayerGetFramesRequest) (*LayerGetFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFrames not implemented")
}
func (UnimplementedLayerInterfaceServer) GetLayer(context.Context, *LayerGetLayerRequest) (*LayerGetLayerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLayer not implemented")
}
func (UnimplementedLayerInterfaceServer) GetLimits(context.Context, *LayerGetLimitsRequest) (*LayerGetLimitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLimits not implemented")
}
func (UnimplementedLayerInterfaceServer) GetOutputPaths(context.Context, *LayerGetOutputPathsRequest) (*LayerGetOutputPathsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOutputPaths not implemented")
}
func (UnimplementedLayerInterfaceServer) GetWhatThisDependsOn(context.Context, *LayerGetWhatThisDependsOnRequest) (*LayerGetWhatThisDependsOnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWhatThisDependsOn not implemented")
}
func (UnimplementedLayerInterfaceServer) GetWhatDependsOnThis(context.Context, *LayerGetWhatDependsOnThisRequest) (*LayerGetWhatDependsOnThisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWhatDependsOnThis not implemented")
}
func (UnimplementedLayerInterfaceServer) KillFrames(context.Context, *LayerKillFramesRequest) (*LayerKillFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillFrames not implemented")
}
func (UnimplementedLayerInterfaceServer) MarkdoneFrames(context.Context, *LayerMarkdoneFramesRequest) (*LayerMarkdoneFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkdoneFrames not implemented")
}
func (UnimplementedLayerInterfaceServer) RegisterOutputPath(context.Context, *LayerRegisterOutputPathRequest) (*LayerRegisterOutputPathResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterOutputPath not implemented")
}
func (UnimplementedLayerInterfaceServer) ReorderFrames(context.Context, *LayerReorderFramesRequest) (*LayerReorderFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReorderFrames not implemented")
}
func (UnimplementedLayerInterfaceServer) RetryFrames(context.Context, *LayerRetryFramesRequest) (*LayerRetryFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetryFrames not implemented")
}
func (UnimplementedLayerInterfaceServer) SetMaxCores(context.Context, *LayerSetMaxCoresRequest) (*LayerSetMaxCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaxCores not implemented")
}
func (UnimplementedLayerInterfaceServer) SetMinCores(context.Context, *LayerSetMinCoresRequest) (*LayerSetMinCoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinCores not implemented")
}
func (UnimplementedLayerInterfaceServer) SetMaxGpus(context.Context, *LayerSetMaxGpusRequest) (*LayerSetMaxGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaxGpus not implemented")
}
func (UnimplementedLayerInterfaceServer) SetMinGpus(context.Context, *LayerSetMinGpusRequest) (*LayerSetMinGpusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinGpus not implemented")
}
func (UnimplementedLayerInterfaceServer) SetMinGpuMemory(context.Context, *LayerSetMinGpuMemoryRequest) (*LayerSetMinGpuMemoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinGpuMemory not implemented")
}
func (UnimplementedLayerInterfaceServer) SetMinGpu(context.Context, *LayerSetMinGpuRequest) (*LayerSetMinGpuResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinGpu not implemented")
}
func (UnimplementedLayerInterfaceServer) SetMinMemory(context.Context, *LayerSetMinMemoryRequest) (*LayerSetMinMemoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinMemory not implemented")
}
func (UnimplementedLayerInterfaceServer) SetTags(context.Context, *LayerSetTagsRequest) (*LayerSetTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTags not implemented")
}
func (UnimplementedLayerInterfaceServer) SetThreadable(context.Context, *LayerSetThreadableRequest) (*LayerSetThreadableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetThreadable not implemented")
}
func (UnimplementedLayerInterfaceServer) SetTimeout(context.Context, *LayerSetTimeoutRequest) (*LayerSetTimeoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTimeout not implemented")
}
func (UnimplementedLayerInterfaceServer) SetTimeoutLLU(context.Context, *LayerSetTimeoutLLURequest) (*LayerSetTimeoutLLUResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTimeoutLLU not implemented")
}
func (UnimplementedLayerInterfaceServer) StaggerFrames(context.Context, *LayerStaggerFramesRequest) (*LayerStaggerFramesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StaggerFrames not implemented")
}
func (UnimplementedLayerInterfaceServer) mustEmbedUnimplementedLayerInterfaceServer() {}

// UnsafeLayerInterfaceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LayerInterfaceServer will
// result in compilation errors.
type UnsafeLayerInterfaceServer interface {
	mustEmbedUnimplementedLayerInterfaceServer()
}

func RegisterLayerInterfaceServer(s grpc.ServiceRegistrar, srv LayerInterfaceServer) {
	s.RegisterService(&LayerInterface_ServiceDesc, srv)
}

func _LayerInterface_AddLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerAddLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).AddLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_AddLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).AddLimit(ctx, req.(*LayerAddLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_AddRenderPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerAddRenderPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).AddRenderPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_AddRenderPartition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).AddRenderPartition(ctx, req.(*LayerAddRenderPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_CreateDependencyOnFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerCreateDependOnFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).CreateDependencyOnFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_CreateDependencyOnFrame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).CreateDependencyOnFrame(ctx, req.(*LayerCreateDependOnFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_CreateDependencyOnJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerCreateDependOnJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).CreateDependencyOnJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_CreateDependencyOnJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).CreateDependencyOnJob(ctx, req.(*LayerCreateDependOnJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_CreateDependencyOnLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerCreateDependOnLayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).CreateDependencyOnLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_CreateDependencyOnLayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).CreateDependencyOnLayer(ctx, req.(*LayerCreateDependOnLayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_CreateFrameByFrameDependency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerCreateFrameByFrameDependRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).CreateFrameByFrameDependency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_CreateFrameByFrameDependency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).CreateFrameByFrameDependency(ctx, req.(*LayerCreateFrameByFrameDependRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_DropDepends_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerDropDependsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).DropDepends(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_DropDepends_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).DropDepends(ctx, req.(*LayerDropDependsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_DropLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerDropLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).DropLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_DropLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).DropLimit(ctx, req.(*LayerDropLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_EatFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerEatFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).EatFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_EatFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).EatFrames(ctx, req.(*LayerEatFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_EnableMemoryOptimizer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerEnableMemoryOptimizerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).EnableMemoryOptimizer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_EnableMemoryOptimizer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).EnableMemoryOptimizer(ctx, req.(*LayerEnableMemoryOptimizerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_FindLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerFindLayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).FindLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_FindLayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).FindLayer(ctx, req.(*LayerFindLayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_GetFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerGetFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).GetFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_GetFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).GetFrames(ctx, req.(*LayerGetFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_GetLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerGetLayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).GetLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_GetLayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).GetLayer(ctx, req.(*LayerGetLayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_GetLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerGetLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).GetLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_GetLimits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).GetLimits(ctx, req.(*LayerGetLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_GetOutputPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerGetOutputPathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).GetOutputPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_GetOutputPaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).GetOutputPaths(ctx, req.(*LayerGetOutputPathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_GetWhatThisDependsOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerGetWhatThisDependsOnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).GetWhatThisDependsOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_GetWhatThisDependsOn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).GetWhatThisDependsOn(ctx, req.(*LayerGetWhatThisDependsOnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_GetWhatDependsOnThis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerGetWhatDependsOnThisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).GetWhatDependsOnThis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_GetWhatDependsOnThis_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).GetWhatDependsOnThis(ctx, req.(*LayerGetWhatDependsOnThisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_KillFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerKillFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).KillFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_KillFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).KillFrames(ctx, req.(*LayerKillFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_MarkdoneFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerMarkdoneFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).MarkdoneFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_MarkdoneFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).MarkdoneFrames(ctx, req.(*LayerMarkdoneFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_RegisterOutputPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerRegisterOutputPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).RegisterOutputPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_RegisterOutputPath_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).RegisterOutputPath(ctx, req.(*LayerRegisterOutputPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_ReorderFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerReorderFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).ReorderFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_ReorderFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).ReorderFrames(ctx, req.(*LayerReorderFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_RetryFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerRetryFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).RetryFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_RetryFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).RetryFrames(ctx, req.(*LayerRetryFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetMaxCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetMaxCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetMaxCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetMaxCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetMaxCores(ctx, req.(*LayerSetMaxCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetMinCores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetMinCoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetMinCores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetMinCores_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetMinCores(ctx, req.(*LayerSetMinCoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetMaxGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetMaxGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetMaxGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetMaxGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetMaxGpus(ctx, req.(*LayerSetMaxGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetMinGpus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetMinGpusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetMinGpus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetMinGpus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetMinGpus(ctx, req.(*LayerSetMinGpusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetMinGpuMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetMinGpuMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetMinGpuMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetMinGpuMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetMinGpuMemory(ctx, req.(*LayerSetMinGpuMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetMinGpu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetMinGpuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetMinGpu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetMinGpu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetMinGpu(ctx, req.(*LayerSetMinGpuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetMinMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetMinMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetMinMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetMinMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetMinMemory(ctx, req.(*LayerSetMinMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetTags(ctx, req.(*LayerSetTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetThreadable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetThreadableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetThreadable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetThreadable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetThreadable(ctx, req.(*LayerSetThreadableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetTimeout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetTimeoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetTimeout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetTimeout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetTimeout(ctx, req.(*LayerSetTimeoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_SetTimeoutLLU_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerSetTimeoutLLURequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).SetTimeoutLLU(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_SetTimeoutLLU_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).SetTimeoutLLU(ctx, req.(*LayerSetTimeoutLLURequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayerInterface_StaggerFrames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LayerStaggerFramesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayerInterfaceServer).StaggerFrames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayerInterface_StaggerFrames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayerInterfaceServer).StaggerFrames(ctx, req.(*LayerStaggerFramesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LayerInterface_ServiceDesc is the grpc.ServiceDesc for LayerInterface service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LayerInterface_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "job.LayerInterface",
	HandlerType: (*LayerInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddLimit",
			Handler:    _LayerInterface_AddLimit_Handler,
		},
		{
			MethodName: "AddRenderPartition",
			Handler:    _LayerInterface_AddRenderPartition_Handler,
		},
		{
			MethodName: "CreateDependencyOnFrame",
			Handler:    _LayerInterface_CreateDependencyOnFrame_Handler,
		},
		{
			MethodName: "CreateDependencyOnJob",
			Handler:    _LayerInterface_CreateDependencyOnJob_Handler,
		},
		{
			MethodName: "CreateDependencyOnLayer",
			Handler:    _LayerInterface_CreateDependencyOnLayer_Handler,
		},
		{
			MethodName: "CreateFrameByFrameDependency",
			Handler:    _LayerInterface_CreateFrameByFrameDependency_Handler,
		},
		{
			MethodName: "DropDepends",
			Handler:    _LayerInterface_DropDepends_Handler,
		},
		{
			MethodName: "DropLimit",
			Handler:    _LayerInterface_DropLimit_Handler,
		},
		{
			MethodName: "EatFrames",
			Handler:    _LayerInterface_EatFrames_Handler,
		},
		{
			MethodName: "EnableMemoryOptimizer",
			Handler:    _LayerInterface_EnableMemoryOptimizer_Handler,
		},
		{
			MethodName: "FindLayer",
			Handler:    _LayerInterface_FindLayer_Handler,
		},
		{
			MethodName: "GetFrames",
			Handler:    _LayerInterface_GetFrames_Handler,
		},
		{
			MethodName: "GetLayer",
			Handler:    _LayerInterface_GetLayer_Handler,
		},
		{
			MethodName: "GetLimits",
			Handler:    _LayerInterface_GetLimits_Handler,
		},
		{
			MethodName: "GetOutputPaths",
			Handler:    _LayerInterface_GetOutputPaths_Handler,
		},
		{
			MethodName: "GetWhatThisDependsOn",
			Handler:    _LayerInterface_GetWhatThisDependsOn_Handler,
		},
		{
			MethodName: "GetWhatDependsOnThis",
			Handler:    _LayerInterface_GetWhatDependsOnThis_Handler,
		},
		{
			MethodName: "KillFrames",
			Handler:    _LayerInterface_KillFrames_Handler,
		},
		{
			MethodName: "MarkdoneFrames",
			Handler:    _LayerInterface_MarkdoneFrames_Handler,
		},
		{
			MethodName: "RegisterOutputPath",
			Handler:    _LayerInterface_RegisterOutputPath_Handler,
		},
		{
			MethodName: "ReorderFrames",
			Handler:    _LayerInterface_ReorderFrames_Handler,
		},
		{
			MethodName: "RetryFrames",
			Handler:    _LayerInterface_RetryFrames_Handler,
		},
		{
			MethodName: "SetMaxCores",
			Handler:    _LayerInterface_SetMaxCores_Handler,
		},
		{
			MethodName: "SetMinCores",
			Handler:    _LayerInterface_SetMinCores_Handler,
		},
		{
			MethodName: "SetMaxGpus",
			Handler:    _LayerInterface_SetMaxGpus_Handler,
		},
		{
			MethodName: "SetMinGpus",
			Handler:    _LayerInterface_SetMinGpus_Handler,
		},
		{
			MethodName: "SetMinGpuMemory",
			Handler:    _LayerInterface_SetMinGpuMemory_Handler,
		},
		{
			MethodName: "SetMinGpu",
			Handler:    _LayerInterface_SetMinGpu_Handler,
		},
		{
			MethodName: "SetMinMemory",
			Handler:    _LayerInterface_SetMinMemory_Handler,
		},
		{
			MethodName: "SetTags",
			Handler:    _LayerInterface_SetTags_Handler,
		},
		{
			MethodName: "SetThreadable",
			Handler:    _LayerInterface_SetThreadable_Handler,
		},
		{
			MethodName: "SetTimeout",
			Handler:    _LayerInterface_SetTimeout_Handler,
		},
		{
			MethodName: "SetTimeoutLLU",
			Handler:    _LayerInterface_SetTimeoutLLU_Handler,
		},
		{
			MethodName: "StaggerFrames",
			Handler:    _LayerInterface_StaggerFrames_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "OpenCue/proto/job.proto",
}
